<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Multi-Level Pipeline</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 15px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            border-top: 4px solid #DC143C;
        }

        .header {
            background: #DC143C;
            color: white;
            padding: 20px 30px;
            text-align: center;
            border-bottom: 1px solid #b01030;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 0.95em;
            opacity: 0.95;
            font-weight: 300;
        }

        .content {
            padding: 25px 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section h2 {
            font-size: 1.3em;
            margin-bottom: 12px;
            color: #DC143C;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .section h2::before {
            content: '';
            width: 3px;
            height: 20px;
            background: #DC143C;
            border-radius: 1px;
        }

        .explanation {
            background: #fafafa;
            padding: 15px 18px;
            border-radius: 3px;
            margin-bottom: 20px;
            border-left: 3px solid #DC143C;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .hierarchy {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 20px 0;
        }

        .level {
            background: white;
            padding: 12px 15px;
            border-radius: 3px;
            border-left: 3px solid #DC143C;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .level:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 6px rgba(220,20,60,0.15);
            border-left-color: #b01030;
        }

        .level-icon {
            font-size: 1.4em;
            width: 35px;
            text-align: center;
        }

        .level-info {
            flex: 1;
        }

        .level-info h3 {
            font-size: 1em;
            margin-bottom: 3px;
            color: #333;
            font-weight: 600;
        }

        .level-info p {
            color: #666;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .arrow {
            font-size: 1em;
            color: #DC143C;
            margin: 0 5px;
            opacity: 0.6;
        }

        .upload-area {
            border: 2px dashed #DC143C;
            border-radius: 3px;
            padding: 25px 20px;
            text-align: center;
            background: #fafafa;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }

        .upload-area:hover {
            background: #fff5f5;
            border-color: #b01030;
        }

        .upload-area.dragover {
            background: #ffe8e8;
            border-color: #b01030;
            border-style: solid;
        }

        .upload-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1em;
            color: #DC143C;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .upload-hint {
            color: #888;
            font-size: 0.85em;
        }

        #fileInput {
            display: none;
        }

        .file-info {
            margin-top: 12px;
            padding: 10px 12px;
            background: #fff5f5;
            border-radius: 3px;
            display: none;
            border-left: 3px solid #DC143C;
        }

        .file-info.show {
            display: block;
        }

        .file-info .filename {
            font-weight: 600;
            color: #DC143C;
            font-size: 0.9em;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .option-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 3px;
            padding: 12px 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .option-card:hover {
            border-color: #DC143C;
            transform: translateY(-2px);
            box-shadow: 0 2px 6px rgba(220,20,60,0.15);
        }

        .option-card.selected {
            border-color: #DC143C;
            background: #fff5f5;
        }

        .option-card input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-bottom: 6px;
            cursor: pointer;
            accent-color: #DC143C;
        }

        .option-card .icon {
            font-size: 1.5em;
            margin-bottom: 6px;
        }

        .option-card label {
            display: block;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            font-size: 0.9em;
        }

        .process-btn {
            background: #DC143C;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 1em;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(220,20,60,0.3);
            margin: 20px auto;
            display: block;
            font-weight: 500;
        }

        .process-btn:hover {
            background: #b01030;
            box-shadow: 0 3px 6px rgba(220,20,60,0.4);
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #ccc;
            box-shadow: none;
        }

        .progress {
            display: none;
            margin: 20px 0;
        }

        .progress.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: #DC143C;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 0.85em;
        }

        .status {
            text-align: center;
            color: #666;
            font-size: 0.85em;
        }

        .results {
            display: none;
            margin-top: 20px;
        }

        .results.show {
            display: block;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .result-card {
            background: #fafafa;
            border-radius: 3px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
        }

        .result-card:hover {
            border-color: #DC143C;
            transform: translateY(-2px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .result-card .icon {
            font-size: 1.5em;
            margin-bottom: 6px;
        }

        .result-card .filename {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
            font-size: 0.9em;
        }

        .result-card .size {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .download-btn {
            background: #DC143C;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 3px;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 500;
        }

        .download-btn:hover {
            background: #b01030;
        }

        .info-badge {
            display: inline-block;
            background: #fff5f5;
            color: #DC143C;
            padding: 3px 8px;
            border-radius: 2px;
            font-size: 0.75em;
            margin: 3px;
            font-weight: 500;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .processing {
            animation: pulse 2s infinite;
        }

        /* Accordion Styles */
        .accordion {
            margin-bottom: 20px;
        }

        .accordion-header {
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 3px;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
            user-select: none;
        }

        .accordion-header:hover {
            background: #efefef;
            border-color: #DC143C;
        }

        .accordion-header.active {
            background: #fff5f5;
            border-color: #DC143C;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .accordion-title {
            font-weight: 600;
            color: #333;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border: 2px solid #e0e0e0;
            border-top: none;
            border-bottom-left-radius: 3px;
            border-bottom-right-radius: 3px;
        }

        .accordion-content.active {
            border-color: #DC143C;
        }

        .accordion-content-inner {
            padding: 20px;
        }
    </style>
    <!-- Built-in Code Database -->
    <script src="lookup_data.js"></script>
    <!-- ZIP Code to FIPS Mapping -->
    <script src="zip_to_fips.js"></script>
    <!-- State Name Mapping -->
    <script src="state_names.js"></script>
    <!-- Leaflet for map preview -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó∫Ô∏è GeoJSON Multi-Level Pipeline</h1>
            <p>Transform your CSV data into beautiful GeoJSON files at multiple geographic levels</p>
        </div>

        <div class="content">
            <!-- Tab Navigation -->
            <div class="tabs" style="display: flex; gap: 10px; margin-bottom: 25px; border-bottom: 2px solid #e0e0e0;">
                <button class="tab-btn active" onclick="showTab('lookup')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üîç Code Lookup Tool
                </button>
                <button class="tab-btn" onclick="showTab('rollup')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üìä CSV Roll-Up
                </button>
                <button class="tab-btn" onclick="showTab('create')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üó∫Ô∏è Create GeoJSON
                </button>
            </div>

            <!-- Code Lookup Tab -->
            <div id="lookupTab" class="tab-content">

            <!-- Collapsible Explanation Section -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('lookupAccordion')">
                    <div class="accordion-title">
                        <span>‚ÑπÔ∏è</span>
                        <span>About This Tool - Why Use Codes?</span>
                    </div>
                    <div class="accordion-icon">‚ñº</div>
                </div>
                <div id="lookupAccordion" class="accordion-content">
                    <div class="accordion-content-inner">
            <div class="section">
                <h2>Red Cross Code Lookup</h2>
                <div class="explanation">
                    <p>Built-in database of all Red Cross chapters, regions, divisions, and counties. Search by name to find ECODE, RCODE, DCODE, and FIPS codes instantly.</p>
                </div>

                <h2>Why Use Codes Instead of Names?</h2>
                <div class="explanation" style="background: #fff5f5; border-left: 3px solid #DC143C;">
                    <p style="font-weight: 600; margin-bottom: 12px; color: #DC143C;">Codes are standardized, unique identifiers that eliminate ambiguity and spelling errors.</p>
                    
                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üìç ZIP Codes (5-digit)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> United States Postal Service ZIP Code Tabulation Areas (ZCTA5)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> 5 digits (e.g., <code>33019</code>, <code>02134</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Every ZIP code is unique. "Miami" could refer to the city, county, or multiple ZIP codes. <code>33101</code> is unambiguous.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üèõÔ∏è FIPS Codes (5-digit)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Federal Information Processing Standards codes for counties</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> 5 digits = State FIPS (2) + County FIPS (3), e.g., <code>12011</code> = Florida (12) + Broward County (011)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> "Dallas" could be Dallas County, TX (<code>48113</code>) or Dallas County, AL (<code>01047</code>). FIPS codes are unique nationwide and never change.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üìö ECODE (Chapter Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross chapters</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Numeric code (e.g., <code>1019</code>, <code>38300</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> "Red Cross of Kentucky" vs "American Red Cross Kentucky Region" vs "ARC Kentucky" - all refer to the same chapter, but <code>1019</code> is always correct.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üåç RCODE (Region Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross regions</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Alphanumeric (e.g., <code>01R04</code>, <code>38R28</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Region names change over time, but codes remain stable. "Southeast Region" might become "Southeast and Caribbean Division" - the code stays the same.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üåé DCODE (Division Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross divisions</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Alphanumeric (e.g., <code>D25</code>, <code>D27</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Division names are long and can be abbreviated differently. <code>D25</code> is always "Southeast and Caribbean Division" regardless of how it's written.</p>
                    </div>

                    <div style="margin-top: 20px; padding: 12px; background: #f0f0f0; border-radius: 3px;">
                        <p style="font-size: 0.9em; margin: 0;"><strong>üí° Key Benefits:</strong></p>
                        <ul style="font-size: 0.85em; margin: 8px 0 0 20px; padding: 0;">
                            <li>No spelling variations (Jefferson vs Jeffersons vs Jefferson County)</li>
                            <li>No ambiguity (Dallas city vs Dallas County vs Dallas Parish)</li>
                            <li>Standardized format (always 5 digits for FIPS, always consistent)</li>
                            <li>Never change (names change, codes stay the same)</li>
                            <li>Perfect for joins (codes match exactly, names require fuzzy matching)</li>
                            <li>International standards (FIPS is federal standard, ZIP is USPS standard)</li>
                        </ul>
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>

            <!-- Search Tool Section -->
            <div class="section">
                    <div style="display: grid; grid-template-columns: 350px 1fr; gap: 30px;">
                        <!-- Left: Search Boxes -->
                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <button onclick="resetSearch()"
                                    style="padding: 10px 20px; background: #DC143C; color: white; border: none; border-radius: 3px; font-weight: 600; font-size: 0.9em; cursor: pointer; margin-bottom: 10px; transition: background 0.2s;"
                                    onmouseover="this.style.background='#b01030'"
                                    onmouseout="this.style.background='#DC143C'">
                                üîÑ Reset All Searches
                            </button>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Chapter Name or ECODE</label>
                                <input type="text" id="chapterSearch" placeholder="e.g., ARC serving Mid Alabama or 1019"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Region Name or RCODE</label>
                                <input type="text" id="regionSearch" placeholder="e.g., Alabama Region or 01R04"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Division Name or DCODE</label>
                                <input type="text" id="divisionSearch" placeholder="e.g., Southeast Division or D25"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e0e0e0;">
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">ZIP Code</label>
                                <input type="text" id="zipSearch" placeholder="e.g., 33704"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">County Name</label>
                                <input type="text" id="countySearch" placeholder="e.g., Broward"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">State (shows state code + counties)</label>
                                <input type="text" id="stateSearch" placeholder="e.g., FL or Florida"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">FIPS Code (5-digit: State+County)</label>
                                <input type="text" id="fipsSearch" placeholder="e.g., 12011 (FL=12, Broward=011)"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>
                        </div>

                        <!-- Right: Results -->
                        <div id="resultsPanel" style="min-height: 400px; padding: 20px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;">
                            <div id="noResults" style="text-align: center; padding: 40px; color: #999;">
                                <div style="font-size: 3em; margin-bottom: 15px;">üîç</div>
                                <div style="font-size: 1.1em; font-weight: 500;">Enter a search term to find codes</div>
                                <div style="font-size: 0.9em; margin-top: 8px; color: #bbb;">Search by Chapter, Region, Division, County, State, or FIPS</div>
                            </div>

                            <div id="codeResults" style="display: none;">
                                <h3 style="font-size: 1.1em; margin-bottom: 15px; color: #DC143C; border-bottom: 2px solid #DC143C; padding-bottom: 6px;">Red Cross Codes</h3>
                                <div id="codeResultsContent" style="display: flex; flex-direction: column; gap: 0;"></div>
                            </div>

                            <div id="countyResultsSection" style="display: none; margin-top: 25px;">
                                <h3 style="font-size: 1.1em; margin-bottom: 15px; color: #DC143C; border-bottom: 2px solid #DC143C; padding-bottom: 6px;">County & FIPS Codes</h3>
                                <div id="countyResultsContent" style="display: flex; flex-direction: column; gap: 0;"></div>
                            </div>
                        </div>
                    </div>
            </div>
            </div>

            <!-- CSV Roll-Up Tab -->
            <div id="rollupTab" class="tab-content" style="display: none;">

                <!-- Collapsible Explanation Section -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion('rollupAccordion')">
                        <div class="accordion-title">
                            <span>‚ÑπÔ∏è</span>
                            <span>About CSV Roll-Up Tool</span>
                        </div>
                        <div class="accordion-icon">‚ñº</div>
                    </div>
                    <div id="rollupAccordion" class="accordion-content">
                        <div class="accordion-content-inner">
                            <div class="explanation">
                                <p><strong>What this tool does:</strong></p>
                                <ul style="margin-left: 20px; margin-top: 8px;">
                                    <li>Aggregates row-level CSV data by geographic level (ZIP or County)</li>
                                    <li>Rolls up totals hierarchically: ZIP ‚Üí County ‚Üí Chapter ‚Üí Region ‚Üí Division</li>
                                    <li>Outputs a CSV file with aggregated metrics at each level</li>
                                    <li>Use the output CSV in the "Create GeoJSON" tab to make maps</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Upload Section -->
                <div class="section">
                    <h2>Upload CSV File</h2>
                    <div class="upload-area" id="rollupUploadArea" style="border: 2px dashed #DC143C; border-radius: 3px; padding: 40px; text-align: center; cursor: pointer; background: #fafafa; transition: all 0.2s;">
                        <div style="font-size: 2.5em; margin-bottom: 10px; color: #DC143C;">üìÅ</div>
                        <p style="font-size: 1.1em; margin-bottom: 5px; font-weight: 500;">Drop CSV file here or click to browse</p>
                        <p style="font-size: 0.85em; color: #666;">Upload row-level data with ZIP or County codes</p>
                    </div>
                    <input type="file" id="rollupFileInput" accept=".csv" style="display: none;">

                    <div id="rollupFileInfo" class="file-info" style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-left: 3px solid #DC143C; border-radius: 3px; display: none;">
                        <span style="font-weight: 500;">üìÑ File: </span>
                        <span id="rollupFileName"></span>
                        <span id="rollupFileSize" style="color: #666; margin-left: 10px;"></span>
                    </div>
                </div>

                <!-- Column Detection Section -->
                <div id="rollupColumnDetectionSection" class="section" style="display: none;">
                    <h2>Configure Aggregation</h2>

                    <div style="background: #f0f8ff; padding: 15px; border-radius: 3px; margin-bottom: 20px; border-left: 3px solid #DC143C;">
                        <p style="font-weight: 500; margin-bottom: 8px;">Detected Input Level:</p>
                        <p id="rollupDetectedLevelText" style="font-size: 1.1em; color: #DC143C;"></p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <p style="font-weight: 500; margin-bottom: 10px;">Select metrics to aggregate:</p>
                        <div id="rollupAggregationFields" style="display: flex; flex-direction: column; gap: 10px;">
                            <!-- Aggregation field checkboxes will be inserted here -->
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <p style="font-weight: 500; margin-bottom: 10px;">Select geographic levels to output:</p>
                        <div id="rollupOutputLevels" style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <!-- Level checkboxes will be inserted here -->
                        </div>
                    </div>

                    <button id="rollupProcessBtn" style="width: 100%; padding: 15px; background: #DC143C; color: white; border: none; border-radius: 3px; font-size: 1.1em; cursor: pointer; font-weight: 500; transition: all 0.2s;">
                        üöÄ Process and Generate CSV
                    </button>
                </div>

                <!-- Progress Section -->
                <div id="rollupProgressSection" class="section" style="display: none;">
                    <h2>Processing...</h2>
                    <div style="background: #f5f5f5; border-radius: 3px; overflow: hidden; height: 30px; margin-bottom: 10px;">
                        <div id="rollupProgressFill" style="height: 100%; background: linear-gradient(90deg, #DC143C, #ff4060); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 500; font-size: 0.9em;"></div>
                    </div>
                    <p id="rollupStatus" style="color: #666; font-size: 0.9em; text-align: center;"></p>
                </div>

                <!-- Results Section -->
                <div id="rollupResultSection" class="section" style="display: none;">
                    <h2>Download Results</h2>
                    <div id="rollupResultGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                        <!-- Download buttons will be inserted here -->
                    </div>
                </div>

            </div>

            <!-- Create GeoJSON Tab -->
            <div id="createTab" class="tab-content" style="display: none;">

            <!-- Collapsible Explanation Section -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('createAccordion')">
                    <div class="accordion-title">
                        <span>‚ÑπÔ∏è</span>
                        <span>How It Works - Geographic Hierarchy Explained</span>
                    </div>
                    <div class="accordion-icon">‚ñº</div>
                </div>
                <div id="createAccordion" class="accordion-content">
                    <div class="accordion-content-inner">
            <div class="section">
                <h2>What This Does</h2>
                <div class="explanation">
                    <p>This tool takes your CSV file with geographic identifiers (ZIP codes, FIPS codes, etc.) and automatically creates GeoJSON files at multiple aggregation levels. Perfect for creating choropleth maps in ArcGIS Online, web applications, or data visualization tools.</p>
                </div>

                <h2>Geographic Hierarchy</h2>
                <div class="hierarchy">
                    <div class="level">
                        <div class="level-icon">üì¶</div>
                        <div class="level-info">
                            <h3>ZIP Codes</h3>
                            <p>Most granular level - includes all original data fields. Perfect for detailed analysis.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üèõÔ∏è</div>
                        <div class="level-info">
                            <h3>Counties</h3>
                            <p>Aggregated from ZIP codes - includes county totals and hierarchy information.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üìö</div>
                        <div class="level-info">
                            <h3>Chapters</h3>
                            <p>Aggregated from counties - boundaries created by merging county polygons.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üåç</div>
                        <div class="level-info">
                            <h3>Regions</h3>
                            <p>Aggregated from chapters - larger geographic areas with regional totals.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üåé</div>
                        <div class="level-info">
                            <h3>Divisions</h3>
                            <p>Highest level - aggregated from regions. Perfect for high-level overviews.</p>
                        </div>
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="section">
                <h2>Step 1: Upload Your CSV File</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì§</div>
                    <div class="upload-text">Drop your CSV file here or click to browse</div>
                    <div class="upload-hint">Your CSV can have individual row-level data (multiple entries per ZIP/County) or pre-aggregated data<br><small style="color: #DC143C; font-weight: 500;">üí° Tip: This tool will automatically aggregate your data by ZIP or County</small></div>
                    <input type="file" id="fileInput" accept=".csv">
                </div>
                <div class="file-info" id="fileInfo">
                    <span class="filename" id="fileName"></span>
                    <span id="fileSize"></span>
                </div>
            </div>

            <!-- Column Detection Section -->
            <div class="section" id="columnDetectionSection" style="display: none;">
                <h2>Step 2: Configure Data Aggregation</h2>

                <!-- Granularity Level -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Input Data Level</h3>
                    <div id="detectedLevel" style="background: #fff5f5; padding: 12px; border-left: 3px solid #DC143C; border-radius: 3px; margin-bottom: 12px;">
                        <strong>Auto-detected:</strong> <span id="detectedLevelText">Analyzing...</span>
                    </div>
                    <div style="display: flex; gap: 15px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 15px; border: 2px solid #e0e0e0; border-radius: 3px; background: white;">
                            <input type="radio" name="granularity" value="zip" id="granularityZip" style="accent-color: #DC143C;">
                            <span>üì¶ ZIP Code Level (detailed)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 15px; border: 2px solid #e0e0e0; border-radius: 3px; background: white;">
                            <input type="radio" name="granularity" value="county" id="granularityCounty" style="accent-color: #DC143C;">
                            <span>üèõÔ∏è County Level (aggregated)</span>
                        </label>
                    </div>
                </div>

                <!-- Aggregation Fields -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Select Fields to Aggregate</h3>
                    <div class="explanation" style="margin-bottom: 15px;">
                        <p><strong>COUNT</strong> = Count number of rows | <strong>SUM</strong> = Add up values in a column</p>
                    </div>
                    <div id="aggregationFields" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Column Mapping -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Geographic Columns Detected</h3>
                    <div id="columnMapping" style="background: #fafafa; padding: 15px; border-radius: 3px; border: 1px solid #e0e0e0;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Options Section -->
            <div class="section" id="outputLevelsSection">
                <h2>Step 3: Select Output Levels</h2>
                <p style="margin-bottom: 12px; color: #666; font-size: 0.9em;">Choose which GeoJSON files you want to create (with hierarchical roll-ups):</p>
                <div class="options">
                    <div class="option-card" data-level="zip">
                        <input type="checkbox" id="optZip" checked>
                        <div class="icon">üì¶</div>
                        <label for="optZip">ZIP Codes</label>
                        <div class="info-badge">All fields</div>
                    </div>
                    <div class="option-card" data-level="county">
                        <input type="checkbox" id="optCounty" checked>
                        <div class="icon">üèõÔ∏è</div>
                        <label for="optCounty">Counties</label>
                        <div class="info-badge">Aggregated</div>
                    </div>
                    <div class="option-card" data-level="chapter">
                        <input type="checkbox" id="optChapter">
                        <div class="icon">üìö</div>
                        <label for="optChapter">Chapters</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                    <div class="option-card" data-level="region">
                        <input type="checkbox" id="optRegion">
                        <div class="icon">üåç</div>
                        <label for="optRegion">Regions</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                    <div class="option-card" data-level="division">
                        <input type="checkbox" id="optDivision">
                        <div class="icon">üåé</div>
                        <label for="optDivision">Divisions</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                </div>
            </div>

            <!-- Aggregation Summary -->
            <div class="section" id="aggregationSummary" style="display: none;">
                <div style="background: #fff5f5; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #DC143C;">üìä Aggregation Summary</h3>
                    <div id="summaryContent" style="font-size: 0.9em; line-height: 1.6;"></div>
                </div>
            </div>

            <!-- Process Button -->
            <button class="process-btn" id="processBtn" disabled>üöÄ Aggregate Data & Create GeoJSON Files</button>

            <!-- Progress Section -->
            <div class="progress" id="progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div class="status" id="status">Ready to process...</div>
            </div>

            <!-- Preview Map Section -->
            <div class="results" id="previewSection" style="display: none;">
                <h2>Map Preview</h2>
                <div style="margin-bottom: 15px;">
                    <label for="previewLevel" style="font-weight: 600; margin-right: 10px;">View Level:</label>
                    <select id="previewLevel" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 3px;">
                        <option value="zip">ZIP Codes</option>
                        <option value="county">Counties</option>
                        <option value="chapter">Chapters</option>
                        <option value="region">Regions</option>
                        <option value="division">Divisions</option>
                    </select>
                </div>
                <div id="map" style="height: 500px; border: 2px solid #e0e0e0; border-radius: 3px;"></div>
            </div>

            <!-- Results Section -->
            <div class="results" id="results">
                <h2>Generated Files</h2>
                <div class="result-grid" id="resultGrid"></div>
            </div>
            </div>
        </div>
    </div>

    <script>
        // File handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const processBtn = document.getElementById('processBtn');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const resultGrid = document.getElementById('resultGrid');

        let selectedFile = null;
        let csvData = null;
        let detectedColumns = null;
        let aggregationConfig = {
            fields: [],
            granularity: null
        };

        // Geographic boundary data (loaded on demand)
        let geoBoundaries = {
            zip: null,
            county: null,
            chapter: null,
            region: null,
            division: null
        };

        // Generated GeoJSON results
        let generatedGeoJSON = {
            zip: null,
            county: null,
            chapter: null,
            region: null,
            division: null
        };

        // Leaflet map
        let previewMap = null;
        let currentLayer = null;

        // Upload area click
        uploadArea.addEventListener('click', () => fileInput.click());

        // File input change
        fileInput.addEventListener('change', (e) => {
            handleFile(e.target.files[0]);
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFile(e.dataTransfer.files[0]);
        });

        function handleFile(file) {
            if (!file || !file.name.endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = `(${(file.size / 1024).toFixed(2)} KB)`;
            fileInfo.classList.add('show');

            // Parse CSV and detect columns
            parseAndDetectColumns(file);
        }

        // Parse CSV and detect columns
        function parseAndDetectColumns(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const rows = text.split('\n').filter(row => row.trim());

                if (rows.length === 0) {
                    alert('CSV file is empty');
                    return;
                }

                // Parse header and first few rows
                // Remove BOM if present and clean headers
                const headers = rows[0].split(',').map(h => h.trim().replace(/"/g, '').replace(/^\uFEFF/, ''));
                const dataRows = rows.slice(1, Math.min(100, rows.length)).map(row => {
                    return row.split(',').map(cell => cell.trim().replace(/"/g, ''));
                });

                csvData = { headers, rows: dataRows, fullText: text };

                // Detect columns
                detectColumns(headers, dataRows);
            };
            reader.readAsText(file);
        }

        // Detect column types
        function detectColumns(headers, dataRows) {
            detectedColumns = {
                zip: null,
                fips: null,
                ecode: null,
                rcode: null,
                dcode: null,
                numeric: [],
                all: headers
            };

            // Flexible column name matching
            const zipPatterns = ['zip', 'zipcode', 'zip_code', 'postal', 'postalcode'];
            const fipsPatterns = ['fips', 'county_fips', 'countyfips', 'geoid', 'county_code'];
            const ecodePatterns = ['ecode', 'chapter', 'chapter_code', 'chaptercode'];
            const rcodePatterns = ['rcode', 'region', 'region_code', 'regioncode'];
            const dcodePatterns = ['dcode', 'division', 'division_code', 'divisioncode'];

            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase();

                // Check for geographic columns
                if (zipPatterns.some(p => headerLower.includes(p))) {
                    detectedColumns.zip = { name: header, index };
                } else if (fipsPatterns.some(p => headerLower.includes(p))) {
                    detectedColumns.fips = { name: header, index };
                } else if (ecodePatterns.some(p => headerLower.includes(p))) {
                    detectedColumns.ecode = { name: header, index };
                } else if (rcodePatterns.some(p => headerLower.includes(p))) {
                    detectedColumns.rcode = { name: header, index };
                } else if (dcodePatterns.some(p => headerLower.includes(p))) {
                    detectedColumns.dcode = { name: header, index };
                }

                // Check if column is numeric (sample first 10 rows)
                // Skip if this column was already identified as a geographic column
                const isGeoColumn = detectedColumns.zip?.index === index ||
                                   detectedColumns.fips?.index === index ||
                                   detectedColumns.ecode?.index === index ||
                                   detectedColumns.rcode?.index === index ||
                                   detectedColumns.dcode?.index === index;

                if (!isGeoColumn) {
                    const sample = dataRows.slice(0, 10).map(row => row[index]);
                    // Check if values are numeric (allow empty strings)
                    const numericValues = sample.filter(val => val !== '');
                    const isNumeric = numericValues.length > 0 &&
                                     numericValues.every(val => !isNaN(parseFloat(val)));

                    if (isNumeric) {
                        detectedColumns.numeric.push({ name: header, index });
                    }
                }
            });

            // Auto-detect granularity
            let detectedGranularity = 'county'; // default
            if (detectedColumns.zip) {
                detectedGranularity = 'zip';
            }

            // Update UI
            displayColumnDetection(detectedGranularity);
            processBtn.disabled = false;
        }

        // Display column detection results
        function displayColumnDetection(detectedGranularity) {
            // Show the section
            document.getElementById('columnDetectionSection').style.display = 'block';

            // Set detected level
            document.getElementById('detectedLevelText').textContent =
                detectedGranularity === 'zip' ? 'ZIP Code Level (found ZIP column)' : 'County Level (found FIPS/County column)';

            // Set radio button
            if (detectedGranularity === 'zip') {
                document.getElementById('granularityZip').checked = true;
            } else {
                document.getElementById('granularityCounty').checked = true;
            }
            aggregationConfig.granularity = detectedGranularity;

            // Display aggregation field options
            const fieldsContainer = document.getElementById('aggregationFields');
            fieldsContainer.innerHTML = '';

            // Add COUNT option
            const countOption = createAggregationFieldOption('Row Count', 'count', 'COUNT');
            fieldsContainer.appendChild(countOption);

            // Add numeric columns (only Drives and RBC fields)
            const allowedSumFields = ['Drives', 'RBC Product Projection', 'RBC Products Collected'];
            detectedColumns.numeric.forEach(col => {
                if (allowedSumFields.includes(col.name)) {
                    const option = createAggregationFieldOption(col.name, col.name, 'SUM', true);
                    fieldsContainer.appendChild(option);
                }
            });

            // Display column mapping
            const mappingContainer = document.getElementById('columnMapping');
            let mappingHtml = '<div style="display: grid; grid-template-columns: 150px 1fr; gap: 10px; font-size: 0.9em;">';

            if (detectedColumns.zip) {
                mappingHtml += `<strong>ZIP Code:</strong><span>${detectedColumns.zip.name}</span>`;
            }
            if (detectedColumns.fips) {
                mappingHtml += `<strong>County FIPS:</strong><span>${detectedColumns.fips.name}</span>`;
            }
            if (detectedColumns.ecode) {
                mappingHtml += `<strong>Chapter (ECODE):</strong><span>${detectedColumns.ecode.name}</span>`;
            }
            if (detectedColumns.rcode) {
                mappingHtml += `<strong>Region (RCODE):</strong><span>${detectedColumns.rcode.name}</span>`;
            }
            if (detectedColumns.dcode) {
                mappingHtml += `<strong>Division (DCODE):</strong><span>${detectedColumns.dcode.name}</span>`;
            }

            mappingHtml += '</div>';
            mappingContainer.innerHTML = mappingHtml;

            // Update option cards
            updateOptionCards();

            // Show and update aggregation summary
            updateAggregationSummary();
        }

        // Update aggregation summary
        function updateAggregationSummary() {
            if (!aggregationConfig.fields || aggregationConfig.fields.length === 0) {
                document.getElementById('aggregationSummary').style.display = 'none';
                return;
            }

            document.getElementById('aggregationSummary').style.display = 'block';

            let summaryHtml = '<ul style="margin: 0; padding-left: 20px;">';
            summaryHtml += `<li><strong>Input Level:</strong> ${aggregationConfig.granularity === 'zip' ? 'ZIP Code' : 'County'}</li>`;
            summaryHtml += '<li><strong>Metrics to aggregate:</strong><ul style="margin-top: 5px;">';

            aggregationConfig.fields.forEach(field => {
                summaryHtml += `<li>${field.label}: <code>${field.type}</code></li>`;
            });

            summaryHtml += '</ul></li>';
            summaryHtml += '<li><strong>Hierarchical roll-ups:</strong> ';

            if (aggregationConfig.granularity === 'zip') {
                summaryHtml += 'ZIP ‚Üí County ‚Üí Chapter ‚Üí Region ‚Üí Division';
            } else {
                summaryHtml += 'County ‚Üí Chapter ‚Üí Region ‚Üí Division';
            }

            summaryHtml += '</li>';
            summaryHtml += '</ul>';

            document.getElementById('summaryContent').innerHTML = summaryHtml;
        }

        // Create aggregation field option
        function createAggregationFieldOption(label, fieldName, defaultType, checked = true) {
            const div = document.createElement('div');
            div.style.cssText = 'display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = checked;
            checkbox.id = `agg_${fieldName}`;
            checkbox.style.cssText = 'width: 18px; height: 18px; accent-color: #DC143C;';

            const labelEl = document.createElement('label');
            labelEl.textContent = label;
            labelEl.style.cssText = 'flex: 1; font-weight: 500; cursor: pointer;';
            labelEl.htmlFor = `agg_${fieldName}`;

            const select = document.createElement('select');
            select.style.cssText = 'padding: 6px 10px; border: 1px solid #e0e0e0; border-radius: 3px; background: white;';
            select.innerHTML = `
                <option value="COUNT" ${defaultType === 'COUNT' ? 'selected' : ''}>COUNT</option>
                <option value="SUM" ${defaultType === 'SUM' ? 'selected' : ''}>SUM</option>
            `;

            // Update config on change
            const updateConfig = () => {
                if (checkbox.checked) {
                    aggregationConfig.fields = aggregationConfig.fields.filter(f => f.field !== fieldName);
                    aggregationConfig.fields.push({
                        field: fieldName,
                        type: select.value,
                        label: label
                    });
                } else {
                    aggregationConfig.fields = aggregationConfig.fields.filter(f => f.field !== fieldName);
                }
                updateAggregationSummary();
            };

            checkbox.addEventListener('change', updateConfig);
            select.addEventListener('change', updateConfig);

            // Initial config
            updateConfig();

            div.appendChild(checkbox);
            div.appendChild(labelEl);
            div.appendChild(select);

            return div;
        }

        // Update granularity on radio change
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('input[name="granularity"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    aggregationConfig.granularity = e.target.value;
                    updateAggregationSummary();
                });
            });
        });

        // Option card interactions
        document.querySelectorAll('.option-card').forEach(card => {
            const checkbox = card.querySelector('input[type="checkbox"]');
            
            card.addEventListener('click', (e) => {
                if (e.target !== checkbox) {
                    checkbox.checked = !checkbox.checked;
                }
                updateCardState(card, checkbox.checked);
            });

            checkbox.addEventListener('change', () => {
                updateCardState(card, checkbox.checked);
            });
        });

        function updateCardState(card, checked) {
            if (checked) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
        }

        function updateOptionCards() {
            document.querySelectorAll('.option-card').forEach(card => {
                updateCardState(card, card.querySelector('input[type="checkbox"]').checked);
            });
        }

        // Process button
        processBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            const selectedLevels = [];
            if (document.getElementById('optZip').checked) selectedLevels.push('zip');
            if (document.getElementById('optCounty').checked) selectedLevels.push('county');
            if (document.getElementById('optChapter').checked) selectedLevels.push('chapter');
            if (document.getElementById('optRegion').checked) selectedLevels.push('region');
            if (document.getElementById('optDivision').checked) selectedLevels.push('division');

            if (selectedLevels.length === 0) {
                alert('Please select at least one output level');
                return;
            }

            // Validate aggregation config
            if (!aggregationConfig.fields || aggregationConfig.fields.length === 0) {
                alert('Please select at least one field to aggregate');
                return;
            }

            processBtn.disabled = true;
            progress.classList.add('show');
            results.classList.remove('show');
            resultGrid.innerHTML = '';

            // Log configuration for backend processing
            console.log('Aggregation Configuration:', {
                granularity: aggregationConfig.granularity,
                fields: aggregationConfig.fields,
                detectedColumns: detectedColumns,
                outputLevels: selectedLevels
            });

            // Upload file first, then process with aggregation
            try {
                await uploadAndProcess(selectedLevels);
            } catch (error) {
                alert('Error: ' + error.message);
                processBtn.disabled = false;
            }
        });

        // CLIENT-SIDE PROCESSING
        async function uploadAndProcess(levels) {
            try {
                // Step 1: Parse full CSV
                updateProgress(5, 'Parsing CSV file...');
                const fullCSV = await parseFullCSV(selectedFile);

                // Step 2: Check if data is already aggregated or needs aggregation
                const isPreAggregated = detectIfPreAggregated(fullCSV);
                let aggregated;

                if (isPreAggregated) {
                    updateProgress(15, 'Detected pre-aggregated CSV, using data directly...');
                    aggregated = convertPreAggregatedToFormat(fullCSV);
                    console.log('‚úì Using pre-aggregated data from CSV Roll-Up tab');
                } else {
                    updateProgress(15, `Aggregating row-level data at ${aggregationConfig.granularity} level...`);
                    aggregated = aggregateData(fullCSV);
                    console.log('‚úì Aggregated row-level data');
                }

                // Step 3: Load boundary files for selected levels
                updateProgress(30, 'Loading geographic boundaries...');
                await loadBoundaries(levels);

                // Step 4: Perform joins and create GeoJSON
                updateProgress(50, 'Creating GeoJSON files...');
                await createGeoJSONFiles(aggregated, levels);

                // Step 5: Show preview map
                updateProgress(90, 'Generating preview map...');
                showPreviewMap(levels[0]);

                // Step 6: Display download links
                updateProgress(100, 'Complete! All files generated successfully.');
                displayDownloadLinks(levels);

                processBtn.disabled = false;
                processBtn.textContent = '‚ú® Process Complete - Upload Another File';
            } catch (error) {
                throw error;
            }
        }

        // Detect if CSV is pre-aggregated (from Roll-Up tab) or row-level
        function detectIfPreAggregated(csvData) {
            const { headers } = csvData;

            // Pre-aggregated CSVs have columns like "Row Count", "Drives", "RBC Product Projection"
            const aggregatedFieldNames = ['Row Count', 'Drives', 'RBC Product Projection', 'RBC Products Collected'];
            const hasAggregatedFields = aggregatedFieldNames.some(field => headers.includes(field));

            // Pre-aggregated CSVs have a geographic key column but not many other columns
            const hasMinimalColumns = headers.length <= 6; // Key + few metrics

            return hasAggregatedFields && hasMinimalColumns;
        }

        // Convert pre-aggregated CSV to the format expected by createGeoJSONFiles
        function convertPreAggregatedToFormat(csvData) {
            const { headers, dataRows } = csvData;
            const result = {};

            // Find the key column (ZIP, County_FIPS, ECODE, RCODE, or DCODE)
            const keyColumnIndex = headers.findIndex(h =>
                ['ZIP', 'County_FIPS', 'ECODE', 'RCODE', 'DCODE'].includes(h)
            );

            if (keyColumnIndex === -1) {
                throw new Error('Could not find geographic key column in pre-aggregated CSV');
            }

            dataRows.forEach(row => {
                const key = row[keyColumnIndex];
                if (!key) return;

                result[key] = {
                    key: key,
                    aggregates: {}
                };

                // Add all metric columns as aggregates
                headers.forEach((header, index) => {
                    if (index !== keyColumnIndex) {
                        const value = parseFloat(row[index]) || 0;
                        result[key].aggregates[header] = value;
                    }
                });
            });

            console.log(`‚úì Converted ${Object.keys(result).length} pre-aggregated records`);
            return result;
        }

        // Parse entire CSV file
        async function parseFullCSV(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    const rows = text.split('\n').filter(row => row.trim());

                    if (rows.length === 0) {
                        reject(new Error('CSV file is empty'));
                        return;
                    }

                    const headers = rows[0].split(',').map(h => h.trim().replace(/"/g, '').replace(/^\uFEFF/, ''));
                    const dataRows = rows.slice(1).map(row => {
                        return row.split(',').map(cell => cell.trim().replace(/"/g, ''));
                    });

                    resolve({ headers, dataRows });
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // Aggregate CSV data
        function aggregateData(csvData) {
            const { headers, dataRows } = csvData;
            const groupKey = aggregationConfig.granularity === 'zip' ? 'zip' : 'fips';
            const keyColumn = detectedColumns[groupKey];

            if (!keyColumn) {
                throw new Error(`No ${groupKey.toUpperCase()} column found`);
            }

            const grouped = {};

            // Group rows by key
            dataRows.forEach(row => {
                const key = row[keyColumn.index];
                if (!key) return;

                if (!grouped[key]) {
                    grouped[key] = {
                        key: key,
                        rows: [],
                        aggregates: {}
                    };
                }
                grouped[key].rows.push(row);
            });

            // Calculate aggregates
            Object.values(grouped).forEach(group => {
                aggregationConfig.fields.forEach(field => {
                    if (field.type === 'COUNT') {
                        group.aggregates[field.field] = group.rows.length;
                    } else if (field.type === 'SUM') {
                        const colIndex = headers.indexOf(field.field);
                        group.aggregates[field.field] = group.rows.reduce((sum, row) => {
                            const val = parseFloat(row[colIndex]) || 0;
                            return sum + val;
                        }, 0);
                    }
                });
            });

            return grouped;
        }

        // Load geographic boundary files
        async function loadBoundaries(levels) {
            const promises = [];

            // Determine base URL for boundary files
            const isLocalhost = window.location.hostname === 'localhost' ||
                               window.location.hostname === '127.0.0.1' ||
                               window.location.hostname === '';

            console.log(`Loading boundaries (hostname: ${window.location.hostname}, isLocalhost: ${isLocalhost})`);

            for (const level of levels) {
                if (!geoBoundaries[level]) {
                    // ZIP boundaries are in Git LFS, need media.githubusercontent.com
                    // Other files are regular Git files, use raw.githubusercontent.com
                    let url;
                    if (isLocalhost) {
                        url = `geographic-data/${level}_boundaries.geojson`;
                    } else if (level === 'zip') {
                        url = `https://media.githubusercontent.com/media/franzenjb/GeoJSON-Creation-Tool/geodata-files/geographic-data/${level}_boundaries.geojson`;
                    } else {
                        url = `https://raw.githubusercontent.com/franzenjb/GeoJSON-Creation-Tool/geodata-files/geographic-data/${level}_boundaries.geojson`;
                    }

                    console.log(`Fetching ${level} from: ${url}`);

                    promises.push(
                        fetch(url)
                            .then(r => {
                                if (!r.ok) {
                                    throw new Error(`Failed to load ${level} boundaries: ${r.status} from ${url}`);
                                }
                                return r.json();
                            })
                            .then(data => {
                                console.log(`‚úì Loaded ${level} boundaries (${data.features?.length || 0} features)`);
                                geoBoundaries[level] = data;
                            })
                            .catch(err => {
                                console.error(`‚úó Error loading ${level} boundaries from ${url}:`, err);
                                throw err;
                            })
                    );
                }
            }

            await Promise.all(promises);
        }

        // Create GeoJSON files with joins
        async function createGeoJSONFiles(aggregated, levels) {
            for (const level of levels) {
                const boundary = geoBoundaries[level];
                if (!boundary) continue;

                // Clone boundary and add aggregated data
                const output = JSON.parse(JSON.stringify(boundary));

                // Proper join logic for each level
                let joinedCount = 0;

                output.features.forEach(feature => {
                    const props = feature.properties;
                    let matchKey = null;

                    // Determine the correct property key for this level
                    if (level === 'zip') {
                        matchKey = props.ZIP || props.ZCTA5CE20;
                    } else if (level === 'county') {
                        matchKey = props.County_FIPS || props.GEOID;
                    } else if (level === 'chapter') {
                        matchKey = props.ECODE;
                    } else if (level === 'region') {
                        matchKey = props.RCODE;
                    } else if (level === 'division') {
                        matchKey = props.DCODE;
                    }

                    // Match and add aggregated data
                    if (matchKey && aggregated[matchKey]) {
                        Object.assign(props, aggregated[matchKey].aggregates);
                        joinedCount++;
                    }
                });

                console.log(`‚úì Joined ${joinedCount} features at ${level} level (out of ${output.features.length})`);
                generatedGeoJSON[level] = output;
            }
        }

        // Show preview map
        function showPreviewMap(initialLevel) {
            document.getElementById('previewSection').style.display = 'block';
            document.getElementById('previewSection').classList.add('show');

            if (!previewMap) {
                previewMap = L.map('map').setView([39.8283, -98.5795], 4);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(previewMap);

                // Add level selector handler
                document.getElementById('previewLevel').addEventListener('change', (e) => {
                    updateMapLayer(e.target.value);
                });
            }

            updateMapLayer(initialLevel);
        }

        // Update map layer
        function updateMapLayer(level) {
            if (currentLayer) {
                previewMap.removeLayer(currentLayer);
            }

            const geoJSON = generatedGeoJSON[level];
            if (!geoJSON) return;

            currentLayer = L.geoJSON(geoJSON, {
                style: feature => ({
                    fillColor: getColor(feature.properties),
                    weight: 1,
                    opacity: 1,
                    color: 'white',
                    fillOpacity: 0.7
                }),
                onEachFeature: (feature, layer) => {
                    layer.bindPopup(createPopup(feature.properties));
                }
            }).addTo(previewMap);

            previewMap.fitBounds(currentLayer.getBounds());
        }

        // Get color for choropleth
        function getColor(properties) {
            const firstMetric = aggregationConfig.fields[0];
            if (!firstMetric) return '#cccccc';

            const value = properties[firstMetric.field] || 0;
            return value > 100 ? '#800026' :
                   value > 50  ? '#BD0026' :
                   value > 20  ? '#E31A1C' :
                   value > 10  ? '#FC4E2A' :
                   value > 5   ? '#FD8D3C' :
                   value > 2   ? '#FEB24C' :
                   value > 0   ? '#FED976' :
                                 '#FFEDA0';
        }

        // Create popup content
        function createPopup(properties) {
            let html = '<div style="font-size: 0.9em;">';
            html += `<strong>${properties.NAME || properties.ZIP || 'Unknown'}</strong><br>`;
            aggregationConfig.fields.forEach(field => {
                html += `${field.label}: ${properties[field.field] || 0}<br>`;
            });
            html += '</div>';
            return html;
        }

        // Display download links
        function displayDownloadLinks(levels) {
            resultGrid.innerHTML = '';

            levels.forEach(level => {
                if (generatedGeoJSON[level]) {
                    const jsonString = JSON.stringify(generatedGeoJSON[level]);
                    const size = new Blob([jsonString]).size;
                    createResultCard(level, `${level}_output.geojson`, size, null, jsonString);
                }
            });

            results.classList.add('show');
        }

        function updateProgress(percent, message) {
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
            status.textContent = message;
        }

        function createResultCard(level, filename, sizeBytes, filepath, jsonString) {
            const levelInfo = {
                zip: { icon: 'üì¶', name: 'ZIP Codes' },
                county: { icon: 'üèõÔ∏è', name: 'Counties' },
                chapter: { icon: 'üìö', name: 'Chapters' },
                region: { icon: 'üåç', name: 'Regions' },
                division: { icon: 'üåé', name: 'Divisions' }
            };

            const info = levelInfo[level] || { icon: 'üìÑ', name: level };
            const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);

            const card = document.createElement('div');
            card.className = 'result-card';
            card.innerHTML = `
                <div class="icon">${info.icon}</div>
                <div class="filename">${filename}</div>
                <div class="size">${sizeMB} MB</div>
                <button class="download-btn">Download</button>
            `;

            // Add click handler for client-side download
            const downloadBtn = card.querySelector('.download-btn');
            downloadBtn.addEventListener('click', () => {
                downloadGeoJSON(jsonString, filename);
            });

            resultGrid.appendChild(card);
            results.classList.add('show');
        }

        // Client-side download
        function downloadGeoJSON(jsonString, filename) {
            const blob = new Blob([jsonString], { type: 'application/geo+json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function downloadFile(filepath) {
            try {
                const response = await fetch(`/api/download/${filepath}`);
                if (!response.ok) {
                    throw new Error('Download failed');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                alert('Error downloading file: ' + error.message);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Tab functionality
        function showTab(tabName) {
            // Hide all tabs
            document.getElementById('createTab').style.display = 'none';
            document.getElementById('lookupTab').style.display = 'none';
            document.getElementById('rollupTab').style.display = 'none';

            // Remove active class from all buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.style.borderBottomColor = 'transparent';
                btn.style.color = '#666';
            });

            // Show selected tab
            if (tabName === 'lookup') {
                document.getElementById('lookupTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[0].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[0].style.color = '#DC143C';
            } else if (tabName === 'rollup') {
                document.getElementById('rollupTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[1].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[1].style.color = '#DC143C';
            } else if (tabName === 'create') {
                document.getElementById('createTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[2].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[2].style.color = '#DC143C';
            }
        }

        // Accordion functionality
        function toggleAccordion(accordionId) {
            const content = document.getElementById(accordionId);
            const header = content.previousElementSibling;

            if (content.classList.contains('active')) {
                // Collapse
                content.style.maxHeight = null;
                content.classList.remove('active');
                header.classList.remove('active');
            } else {
                // Expand
                content.classList.add('active');
                header.classList.add('active');
                content.style.maxHeight = content.scrollHeight + 'px';
            }
        }

        // ==================== CSV ROLL-UP TAB FUNCTIONALITY ====================

        // CSV Roll-Up state
        let rollupCsvData = null;
        let rollupDetectedColumns = null;
        let rollupAggregationConfig = {
            granularity: null,  // 'zip' or 'county'
            fields: [],
            outputLevels: []
        };
        let rollupGeneratedCSVs = {};

        // Get rollup tab elements
        const rollupUploadArea = document.getElementById('rollupUploadArea');
        const rollupFileInput = document.getElementById('rollupFileInput');
        const rollupFileInfo = document.getElementById('rollupFileInfo');
        const rollupFileName = document.getElementById('rollupFileName');
        const rollupFileSize = document.getElementById('rollupFileSize');
        const rollupColumnDetectionSection = document.getElementById('rollupColumnDetectionSection');
        const rollupDetectedLevelText = document.getElementById('rollupDetectedLevelText');
        const rollupAggregationFields = document.getElementById('rollupAggregationFields');
        const rollupOutputLevels = document.getElementById('rollupOutputLevels');
        const rollupProcessBtn = document.getElementById('rollupProcessBtn');
        const rollupProgressSection = document.getElementById('rollupProgressSection');
        const rollupProgressFill = document.getElementById('rollupProgressFill');
        const rollupStatus = document.getElementById('rollupStatus');
        const rollupResultSection = document.getElementById('rollupResultSection');
        const rollupResultGrid = document.getElementById('rollupResultGrid');

        // Upload handlers for rollup tab
        rollupUploadArea.addEventListener('click', () => rollupFileInput.click());
        rollupFileInput.addEventListener('change', (e) => handleRollupFile(e.target.files[0]));

        rollupUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            rollupUploadArea.style.borderColor = '#ff4060';
            rollupUploadArea.style.background = '#fff5f7';
        });

        rollupUploadArea.addEventListener('dragleave', () => {
            rollupUploadArea.style.borderColor = '#DC143C';
            rollupUploadArea.style.background = '#fafafa';
        });

        rollupUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            rollupUploadArea.style.borderColor = '#DC143C';
            rollupUploadArea.style.background = '#fafafa';
            handleRollupFile(e.dataTransfer.files[0]);
        });

        function handleRollupFile(file) {
            if (!file || !file.name.endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            rollupFileName.textContent = file.name;
            rollupFileSize.textContent = `(${(file.size / 1024).toFixed(2)} KB)`;
            rollupFileInfo.style.display = 'block';

            // Parse CSV and detect columns
            parseRollupCSV(file);
        }

        function parseRollupCSV(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const rows = text.split('\n').filter(row => row.trim());

                if (rows.length === 0) {
                    alert('CSV file is empty');
                    return;
                }

                // Parse header and all rows
                const headers = rows[0].split(',').map(h => h.trim().replace(/"/g, '').replace(/^\uFEFF/, ''));
                const dataRows = rows.slice(1).map(row => {
                    return row.split(',').map(cell => cell.trim().replace(/"/g, ''));
                });

                rollupCsvData = { headers, dataRows };

                // Detect columns
                detectRollupColumns(headers, dataRows);
            };
            reader.readAsText(file);
        }

        function detectRollupColumns(headers, dataRows) {
            rollupDetectedColumns = {
                zip: null,
                fips: null,
                ecode: null,
                rcode: null,
                dcode: null,
                numeric: [],
                all: headers
            };

            // Detect geographic columns
            const zipPatterns = ['zip', 'zipcode', 'zip_code', 'postal', 'postalcode'];
            const fipsPatterns = ['fips', 'county_fips', 'countyfips', 'geoid'];
            const ecodePatterns = ['ecode', 'chapter', 'chaptercode'];
            const rcodePatterns = ['rcode', 'region', 'regioncode'];
            const dcodePatterns = ['dcode', 'division', 'divisioncode'];

            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase();

                if (zipPatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.zip = { name: header, index };
                } else if (fipsPatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.fips = { name: header, index };
                } else if (ecodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.ecode = { name: header, index };
                } else if (rcodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.rcode = { name: header, index };
                } else if (dcodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.dcode = { name: header, index };
                }

                // Check if column is numeric
                const isGeoColumn =
                    rollupDetectedColumns.zip?.index === index ||
                    rollupDetectedColumns.fips?.index === index ||
                    rollupDetectedColumns.ecode?.index === index ||
                    rollupDetectedColumns.rcode?.index === index ||
                    rollupDetectedColumns.dcode?.index === index;

                if (!isGeoColumn) {
                    const sample = dataRows.slice(0, 10).map(row => row[index]);
                    const numericValues = sample.filter(val => val !== '');
                    const isNumeric = numericValues.length > 0 &&
                                     numericValues.every(val => !isNaN(parseFloat(val)));
                    if (isNumeric) {
                        rollupDetectedColumns.numeric.push({ name: header, index });
                    }
                }
            });

            // Determine granularity
            const detectedGranularity = rollupDetectedColumns.zip ? 'zip' :
                                       rollupDetectedColumns.fips ? 'county' : null;

            if (!detectedGranularity) {
                alert('Could not detect ZIP or County FIPS column. Please ensure your CSV has a column with ZIP codes or County FIPS codes.');
                return;
            }

            rollupAggregationConfig.granularity = detectedGranularity;

            // Display column detection results
            displayRollupColumnDetection(detectedGranularity);
        }

        function displayRollupColumnDetection(detectedGranularity) {
            // Show the section
            rollupColumnDetectionSection.style.display = 'block';

            // Set detected level
            rollupDetectedLevelText.textContent =
                detectedGranularity === 'zip' ? 'ZIP Code Level (found ZIP column)' : 'County Level (found FIPS/County column)';

            // Display aggregation field options
            rollupAggregationFields.innerHTML = '';

            // Add COUNT option
            const countOption = createRollupFieldOption('Row Count', 'count', 'COUNT');
            rollupAggregationFields.appendChild(countOption);

            // Add numeric columns (only Drives and RBC fields)
            const allowedSumFields = ['Drives', 'RBC Product Projection', 'RBC Products Collected'];
            rollupDetectedColumns.numeric.forEach(col => {
                if (allowedSumFields.includes(col.name)) {
                    const option = createRollupFieldOption(col.name, col.name, 'SUM', true);
                    rollupAggregationFields.appendChild(option);
                }
            });

            // Display output level options
            rollupOutputLevels.innerHTML = '';
            const levels = detectedGranularity === 'zip'
                ? ['zip', 'county', 'chapter', 'region', 'division']
                : ['county', 'chapter', 'region', 'division'];

            levels.forEach(level => {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `rollupLevel${level}`;
                checkbox.checked = true;
                checkbox.style.marginRight = '5px';

                const label = document.createElement('label');
                label.htmlFor = `rollupLevel${level}`;
                label.textContent = level.charAt(0).toUpperCase() + level.slice(1);
                label.style.cssText = 'display: flex; align-items: center; padding: 8px 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px; cursor: pointer;';

                const container = document.createElement('div');
                container.appendChild(checkbox);
                container.appendChild(label);

                rollupOutputLevels.appendChild(label);
                label.insertBefore(checkbox, label.firstChild);
            });
        }

        function createRollupFieldOption(label, fieldName, defaultType, checked = true) {
            const div = document.createElement('div');
            div.style.cssText = 'display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = checked;
            checkbox.id = `rollup_field_${fieldName}`;

            const labelEl = document.createElement('label');
            labelEl.htmlFor = `rollup_field_${fieldName}`;
            labelEl.textContent = label;
            labelEl.style.flex = '1';
            labelEl.style.cursor = 'pointer';

            const typeSpan = document.createElement('span');
            typeSpan.textContent = defaultType;
            typeSpan.style.cssText = 'padding: 4px 8px; background: #DC143C; color: white; border-radius: 3px; font-size: 0.85em; font-weight: 500;';

            div.appendChild(checkbox);
            div.appendChild(labelEl);
            div.appendChild(typeSpan);

            // Track in config
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    rollupAggregationConfig.fields.push({
                        field: fieldName,
                        label: label,
                        type: defaultType
                    });
                } else {
                    rollupAggregationConfig.fields = rollupAggregationConfig.fields.filter(f => f.field !== fieldName);
                }
            });

            // Initialize as checked
            if (checked) {
                rollupAggregationConfig.fields.push({
                    field: fieldName,
                    label: label,
                    type: defaultType
                });
            }

            return div;
        }

        // Process button handler
        rollupProcessBtn.addEventListener('click', async () => {
            if (!rollupCsvData || rollupAggregationConfig.fields.length === 0) {
                alert('Please select at least one metric to aggregate');
                return;
            }

            // Get selected output levels
            const selectedLevels = [];
            const levelCheckboxes = rollupOutputLevels.querySelectorAll('input[type="checkbox"]');
            levelCheckboxes.forEach(cb => {
                if (cb.checked) {
                    const level = cb.id.replace('rollupLevel', '');
                    selectedLevels.push(level);
                }
            });

            if (selectedLevels.length === 0) {
                alert('Please select at least one output level');
                return;
            }

            rollupAggregationConfig.outputLevels = selectedLevels;

            // Show progress
            rollupColumnDetectionSection.style.display = 'none';
            rollupProgressSection.style.display = 'block';
            rollupResultSection.style.display = 'none';

            try {
                await processRollupCSV();
            } catch (error) {
                console.error('Error processing CSV:', error);
                alert('Error processing CSV: ' + error.message);
                rollupProgressSection.style.display = 'none';
                rollupColumnDetectionSection.style.display = 'block';
            }
        });

        async function processRollupCSV() {
            updateRollupProgress(10, 'Parsing CSV data...');
            await sleep(100);

            // Step 1: Aggregate by base level (ZIP or County)
            updateRollupProgress(30, 'Aggregating by ' + rollupAggregationConfig.granularity + '...');
            const baseAggregated = aggregateRollupData(rollupCsvData);
            await sleep(100);

            // Step 2: Load boundary files to get hierarchy mapping
            updateRollupProgress(50, 'Loading geographic boundaries...');
            const boundaryData = await loadBoundaryForHierarchy(rollupAggregationConfig.granularity);
            await sleep(100);

            // Step 3: Perform hierarchical roll-ups
            updateRollupProgress(70, 'Performing hierarchical roll-ups...');
            rollupGeneratedCSVs = performHierarchicalRollup(baseAggregated, boundaryData);
            await sleep(100);

            // Step 4: Display download links
            updateRollupProgress(100, 'Complete! CSV files generated successfully.');
            await sleep(500);

            displayRollupDownloadLinks();
        }

        function aggregateRollupData(csvData) {
            const { headers, dataRows } = csvData;
            const groupKey = rollupAggregationConfig.granularity === 'zip' ? 'zip' : 'fips';
            const keyColumn = rollupDetectedColumns[groupKey];

            const grouped = {};

            dataRows.forEach(row => {
                const key = row[keyColumn.index];
                if (!key) return;

                if (!grouped[key]) {
                    grouped[key] = { key: key, rows: [], aggregates: {} };
                }
                grouped[key].rows.push(row);
            });

            // Calculate aggregates
            Object.values(grouped).forEach(group => {
                rollupAggregationConfig.fields.forEach(field => {
                    if (field.type === 'COUNT') {
                        group.aggregates[field.field] = group.rows.length;
                    } else if (field.type === 'SUM') {
                        const colIndex = headers.indexOf(field.field);
                        group.aggregates[field.field] = group.rows.reduce((sum, row) => {
                            const val = parseFloat(row[colIndex]) || 0;
                            return sum + val;
                        }, 0);
                    }
                });
            });

            return grouped;
        }

        async function loadBoundaryForHierarchy(granularity) {
            // Load ZIP code hierarchy lookup from simple CSV file
            const url = 'https://cdn.jsdelivr.net/gh/franzenjb/alice_master_database/subcounty_zip_all_states.csv';

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load ZIP hierarchy lookup: ${response.status}`);
            }

            const csvText = await response.text();
            const lines = csvText.split('\n').filter(line => line.trim());

            // Proper CSV parser that handles quoted fields with commas
            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            const headers = parseCSVLine(lines[0]);

            // Find column indices
            const geoIdIdx = headers.indexOf('GEO_ID');
            const countyIdx = headers.indexOf('County');
            const ecodeIdx = headers.indexOf('ECODE');
            const rcodeIdx = headers.indexOf('RCODE');
            const dcodeIdx = headers.indexOf('DCODE');

            // Parse CSV rows into lookup object
            const lookupData = {};
            lines.slice(1).forEach(line => {
                const values = parseCSVLine(line);
                const geoId = values[geoIdIdx];
                if (!geoId) return;

                // Extract ZIP code (remove _ZCTA suffix if present)
                const zip = geoId.replace('_ZCTA', '');

                lookupData[zip] = {
                    county: values[countyIdx],
                    ecode: values[ecodeIdx],
                    rcode: values[rcodeIdx],
                    dcode: values[dcodeIdx]
                };
            });

            console.log(`‚úì Loaded ${Object.keys(lookupData).length} ZIP code hierarchy mappings`);
            return lookupData;
        }

        function performHierarchicalRollup(baseAggregated, lookupData) {
            const result = {};

            // lookupData is now a simple object: { "zipcode": { county, ecode, rcode, dcode }, ... }
            // Convert to hierarchyMap with standardized keys AND store the codes for ID columns
            const hierarchyMap = {};
            Object.keys(lookupData).forEach(zip => {
                const data = lookupData[zip];
                hierarchyMap[zip] = {
                    county: data.county,
                    chapter: data.ecode,
                    region: data.rcode,
                    division: data.dcode,
                    // Store codes for audit columns
                    county_name: data.county,
                    ecode: data.ecode,
                    rcode: data.rcode,
                    dcode: data.dcode
                };
            });

            // Calculate aggregates at all hierarchical levels
            const countyTotals = {};
            const chapterTotals = {};
            const regionTotals = {};
            const divisionTotals = {};

            Object.keys(baseAggregated).forEach(baseKey => {
                const hierarchy = hierarchyMap[baseKey];
                if (!hierarchy) return;

                const aggregates = baseAggregated[baseKey].aggregates;

                // Accumulate to county level
                if (hierarchy.county) {
                    if (!countyTotals[hierarchy.county]) {
                        countyTotals[hierarchy.county] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            countyTotals[hierarchy.county][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        countyTotals[hierarchy.county][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to chapter level
                if (hierarchy.chapter) {
                    if (!chapterTotals[hierarchy.chapter]) {
                        chapterTotals[hierarchy.chapter] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            chapterTotals[hierarchy.chapter][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        chapterTotals[hierarchy.chapter][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to region level
                if (hierarchy.region) {
                    if (!regionTotals[hierarchy.region]) {
                        regionTotals[hierarchy.region] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            regionTotals[hierarchy.region][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        regionTotals[hierarchy.region][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to division level
                if (hierarchy.division) {
                    if (!divisionTotals[hierarchy.division]) {
                        divisionTotals[hierarchy.division] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            divisionTotals[hierarchy.division][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        divisionTotals[hierarchy.division][field.field] += aggregates[field.field] || 0;
                    });
                }
            });

            // For each selected output level, create CSV with hierarchical columns
            rollupAggregationConfig.outputLevels.forEach(level => {
                const levelData = [];

                if (level === 'zip') {
                    // Each row is a ZIP with its own totals + parent totals
                    Object.keys(baseAggregated).forEach(zipKey => {
                        const hierarchy = hierarchyMap[zipKey];
                        if (!hierarchy) return;

                        const row = {
                            key: zipKey,
                            // Add ID columns for auditing
                            county_name: hierarchy.county_name,
                            ecode: hierarchy.ecode,
                            rcode: hierarchy.rcode,
                            dcode: hierarchy.dcode,
                            // Add aggregated data
                            zip: baseAggregated[zipKey].aggregates,
                            county: countyTotals[hierarchy.county] || {},
                            chapter: chapterTotals[hierarchy.chapter] || {},
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'county') {
                    // Each row is a County with its own totals + parent totals
                    Object.keys(countyTotals).forEach(countyKey => {
                        // Find a ZIP in this county to get hierarchy
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.county === countyKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: countyKey,
                            county: countyTotals[countyKey],
                            chapter: chapterTotals[hierarchy.chapter] || {},
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'chapter') {
                    // Each row is a Chapter with its own totals + parent totals
                    Object.keys(chapterTotals).forEach(chapterKey => {
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.chapter === chapterKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: chapterKey,
                            chapter: chapterTotals[chapterKey],
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'region') {
                    // Each row is a Region with its own totals + parent totals
                    Object.keys(regionTotals).forEach(regionKey => {
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.region === regionKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: regionKey,
                            region: regionTotals[regionKey],
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'division') {
                    // Each row is a Division with its own totals only
                    Object.keys(divisionTotals).forEach(divisionKey => {
                        const row = {
                            key: divisionKey,
                            division: divisionTotals[divisionKey]
                        };
                        levelData.push(row);
                    });
                }

                // Convert to CSV format
                const csv = convertToCSV(level, levelData);
                result[level] = csv;
            });

            return result;
        }

        function convertToCSV(level, data) {
            const levelKeyName = level === 'zip' ? 'ZIP' :
                                level === 'county' ? 'County' :
                                level === 'chapter' ? 'ECODE' :
                                level === 'region' ? 'RCODE' : 'DCODE';

            // Create hierarchical headers based on output level
            const headers = [levelKeyName];

            // Add ID columns for auditing (for ZIP level output)
            if (level === 'zip') {
                headers.push('County', 'ECODE', 'RCODE', 'DCODE');
            }

            const levelOrder = {
                'zip': ['zip', 'county', 'chapter', 'region', 'division'],
                'county': ['county', 'chapter', 'region', 'division'],
                'chapter': ['chapter', 'region', 'division'],
                'region': ['region', 'division'],
                'division': ['division']
            };

            const levelsToInclude = levelOrder[level] || [level];
            const levelLabels = {
                'zip': 'ZIP',
                'county': 'County',
                'chapter': 'Chapter',
                'region': 'Region',
                'division': 'Division'
            };

            // Add headers for each hierarchical level
            levelsToInclude.forEach(lvl => {
                rollupAggregationConfig.fields.forEach(field => {
                    headers.push(`${field.label} (${levelLabels[lvl]})`);
                });
            });

            const rows = [headers.join(',')];

            // Add data rows
            data.forEach(rowData => {
                const values = [rowData.key];

                // Add ID values for auditing (for ZIP level output)
                if (level === 'zip') {
                    values.push(
                        `"${rowData.county_name || ''}"`,
                        rowData.ecode || '',
                        rowData.rcode || '',
                        rowData.dcode || ''
                    );
                }

                levelsToInclude.forEach(lvl => {
                    rollupAggregationConfig.fields.forEach(field => {
                        const value = rowData[lvl] && rowData[lvl][field.field] !== undefined
                            ? rowData[lvl][field.field]
                            : 0;
                        values.push(value);
                    });
                });

                rows.push(values.join(','));
            });

            return rows.join('\n');
        }

        function displayRollupDownloadLinks() {
            rollupResultSection.style.display = 'block';
            rollupResultGrid.innerHTML = '';

            rollupAggregationConfig.outputLevels.forEach(level => {
                if (rollupGeneratedCSVs[level]) {
                    const csv = rollupGeneratedCSVs[level];
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const size = blob.size;

                    const card = createRollupResultCard(level, `${level}_aggregated.csv`, size, csv);
                    rollupResultGrid.appendChild(card);
                }
            });
        }

        function createRollupResultCard(level, filename, sizeBytes, csvContent) {
            const levelInfo = {
                zip: { icon: 'üì¶', name: 'ZIP Codes' },
                county: { icon: 'üèõÔ∏è', name: 'Counties' },
                chapter: { icon: 'üìö', name: 'Chapters' },
                region: { icon: 'üó∫Ô∏è', name: 'Regions' },
                division: { icon: 'üåé', name: 'Divisions' }
            };

            const info = levelInfo[level] || { icon: 'üìÑ', name: level };

            const card = document.createElement('div');
            card.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 3px; padding: 15px; transition: all 0.2s;';

            card.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 2em;">${info.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; font-size: 1.05em; margin-bottom: 2px;">${info.name}</div>
                        <div style="font-size: 0.85em; color: #666;">${(sizeBytes / 1024).toFixed(2)} KB</div>
                    </div>
                </div>
                <button class="download-btn" style="width: 100%; padding: 10px; background: #DC143C; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: 500; transition: all 0.2s;">
                    üíæ Download CSV
                </button>
            `;

            const downloadBtn = card.querySelector('.download-btn');
            downloadBtn.addEventListener('click', () => {
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });

            downloadBtn.addEventListener('mouseenter', () => {
                downloadBtn.style.background = '#b01030';
            });

            downloadBtn.addEventListener('mouseleave', () => {
                downloadBtn.style.background = '#DC143C';
            });

            return card;
        }

        function updateRollupProgress(percent, message) {
            rollupProgressFill.style.width = percent + '%';
            rollupProgressFill.textContent = Math.round(percent) + '%';
            rollupStatus.textContent = message;
        }

        // ==================== END CSV ROLL-UP TAB ====================

        // Code Lookup functionality - Built-in database
        let lookupData = [];
        let countyData = [];
        let zipData = [];
        let zipDataByState = {}; // Cache for state-based ZIP files

        // Load built-in database
        function loadBuiltInDatabase() {
            // This will be populated from the embedded lookup_data.js file
            // For now, initialize empty - will be loaded via script tag
            if (typeof LOOKUP_DATABASE !== 'undefined') {
                lookupData = LOOKUP_DATABASE.chapters || [];
                countyData = LOOKUP_DATABASE.counties || [];
                
                console.log(`‚úì Loaded ${lookupData.length} chapters and ${countyData.length} counties`);
            }
            
            // Load ZIP code mapping (full database)
            if (typeof ZIP_TO_FIPS !== 'undefined') {
                zipData = ZIP_TO_FIPS.zipCodes || [];
                console.log(`‚úì Loaded ${zipData.length} ZIP codes`);
            }
        }

        // Load ZIP codes for a specific state (on-demand)
        async function loadZipCodesForState(state) {
            if (zipDataByState[state]) {
                return zipDataByState[state];
            }
            
            // Try to load state-specific file
            const stateUpper = state.toUpperCase();
            try {
                const script = document.createElement('script');
                script.src = `zip_codes_${stateUpper}.js`;
                script.onload = function() {
                    const stateVarName = `ZIP_CODES_${stateUpper}`;
                    if (typeof window[stateVarName] !== 'undefined') {
                        zipDataByState[state] = window[stateVarName];
                        console.log(`‚úì Loaded ${zipDataByState[state].length} ZIP codes for ${state}`);
                    }
                };
                document.head.appendChild(script);
            } catch (e) {
                console.log(`Could not load ZIP codes for ${state}`);
            }
            
            return zipDataByState[state] || [];
        }

        function searchCodes() {
            // Get all search values
            const chapterQuery = document.getElementById('chapterSearch').value.trim();
            const regionQuery = document.getElementById('regionSearch').value.trim();
            const divisionQuery = document.getElementById('divisionSearch').value.trim();
            const zipQuery = document.getElementById('zipSearch').value.trim();
            const countyQuery = document.getElementById('countySearch').value.trim();
            const stateQuery = document.getElementById('stateSearch').value.trim();
            const fipsQuery = document.getElementById('fipsSearch').value.trim();

            // Check if any search is active
            const hasSearch = chapterQuery || regionQuery || divisionQuery || zipQuery || countyQuery || stateQuery || fipsQuery;
            
            if (!hasSearch) {
                document.getElementById('noResults').style.display = 'block';
                document.getElementById('codeResults').style.display = 'none';
                document.getElementById('countyResultsSection').style.display = 'none';
                return;
            } else {
                document.getElementById('noResults').style.display = 'none';
            }

            // Normalize queries for flexible matching
            const normalize = (str) => str ? str.toLowerCase().trim().replace(/\s+/g, ' ') : '';
            
            // Convert state name to abbreviation if needed
            function normalizeState(stateQuery) {
                if (!stateQuery) return '';
                const normalized = normalize(stateQuery);
                // Check if it's already an abbreviation (2 letters)
                if (normalized.length === 2) {
                    return normalized.toUpperCase();
                }
                // Check if it's a full state name
                if (typeof STATE_NAMES !== 'undefined' && STATE_NAMES[normalized]) {
                    return STATE_NAMES[normalized];
                }
                // Return as-is for partial matching
                return normalized;
            }
            
            // Search Red Cross codes (forward and reverse lookup)
            let results = [];
            if (lookupData.length > 0) {
                results = lookupData.filter(item => {
                    // Chapter/ECODE search - very flexible
                    const chapterMatch = !chapterQuery || 
                        (item.Chapter && normalize(item.Chapter).includes(normalize(chapterQuery))) ||
                        (item.ECODE && item.ECODE.toString().toLowerCase().includes(normalize(chapterQuery))) ||
                        (item.ECODE && item.ECODE.toString().includes(chapterQuery.trim()));
                    
                    // Region/RCODE search - very flexible
                    const regionMatch = !regionQuery || 
                        (item.Region && normalize(item.Region).includes(normalize(regionQuery))) ||
                        (item.RCODE && item.RCODE.toString().toLowerCase().includes(normalize(regionQuery))) ||
                        (item.RCODE && item.RCODE.toString().includes(regionQuery.trim()));
                    
                    // Division/DCODE search - very flexible
                    const divisionMatch = !divisionQuery || 
                        (item.Division && normalize(item.Division).includes(normalize(divisionQuery))) ||
                        (item.DCODE && item.DCODE.toString().toLowerCase().includes(normalize(divisionQuery))) ||
                        (item.DCODE && item.DCODE.toString().includes(divisionQuery.trim()));
                    
                    return chapterMatch && regionMatch && divisionMatch;
                });
            }

            // Search ZIP codes first (if ZIP is searched, find county/FIPS)
            let zipResults = [];
            let zipFoundFIPS = null;
            if (zipQuery) {
                // Normalize ZIP to exactly 5 digits
                const zipNormalized = zipQuery.replace(/[^0-9]/g, '').substring(0, 5).padStart(5, '0');
                
                // Search in main ZIP database
                if (zipData.length > 0) {
                    // First try exact match
                    zipResults = zipData.filter(item => {
                        if (!item.Zip) return false;
                        const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                        return itemZip === zipNormalized;
                    });
                    
                    // If no exact match, try partial match (first 3 digits)
                    if (zipResults.length === 0 && zipNormalized.length >= 3) {
                        const zipPrefix = zipNormalized.substring(0, 3);
                        zipResults = zipData.filter(item => {
                            if (!item.Zip) return false;
                            const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                            return itemZip.startsWith(zipPrefix);
                        });
                    }
                }
                
                // If still no results, try to infer state from ZIP prefix and load state file
                if (zipResults.length === 0 && zipNormalized.length >= 3) {
                    // ZIP codes starting with 33xxx are typically Florida
                    // We could add more logic here to map ZIP prefixes to states
                    const zipPrefix = zipNormalized.substring(0, 2);
                    // Common ZIP prefixes: 33=FL, 10-12=NY/NJ/PA, etc.
                    // For now, if ZIP starts with 33, try loading FL data
                    if (zipPrefix === '33') {
                        loadZipCodesForState('FL').then(flZips => {
                            if (flZips && flZips.length > 0) {
                                const found = flZips.filter(item => {
                                    if (!item.Zip) return false;
                                    const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                                    return itemZip === zipNormalized;
                                });
                                if (found.length > 0) {
                                    zipResults = found;
                                    zipFoundFIPS = found[0].FIPS;
                                    searchCodes(); // Re-run search with new data
                                }
                            }
                        });
                    }
                }
                
                if (zipResults.length > 0) {
                    // Use the FIPS from ZIP results to filter county results
                    zipFoundFIPS = zipResults[0].FIPS;
                }
            }

            // Search counties (forward and reverse lookup)
            let countyResults = [];
            if (countyData.length > 0) {
                // Normalize state query (convert full name to abbreviation if needed)
                const stateQueryNormalized = stateQuery ? normalizeState(stateQuery) : '';
                
                countyResults = countyData.filter(item => {
                    // If ZIP was searched and found a FIPS, prioritize that
                    if (zipFoundFIPS && zipQuery) {
                        return item.FIPS === zipFoundFIPS;
                    }
                    
                    const countyMatch = !countyQuery || 
                        (item.County && normalize(item.County).includes(normalize(countyQuery)));
                    
                    // State matching: convert full name to abbreviation, then match
                    let stateMatch = true;
                    if (stateQuery) {
                        const itemState = (item.State || '').toUpperCase();
                        // stateQueryNormalized is already converted to abbreviation if it was a full name
                        // Match the normalized query (which is now an abbreviation) against the item's state
                        stateMatch = itemState === stateQueryNormalized.toUpperCase() ||
                            // Also allow partial matching on the original query
                            normalize(item.State || '').includes(normalize(stateQuery));
                    }
                    
                    const fipsMatch = !fipsQuery || 
                        (item.FIPS && item.FIPS.toString().includes(fipsQuery.trim()));
                    
                    return countyMatch && stateMatch && fipsMatch;
                });
            }
            
            // If ZIP search found results, add them to county results
            if (zipResults.length > 0 && zipQuery) {
                zipResults.forEach(zipItem => {
                    // Check if this FIPS is already in countyResults
                    const exists = countyResults.some(c => c.FIPS === zipItem.FIPS);
                    if (!exists) {
                        countyResults.push({
                            FIPS: zipItem.FIPS,
                            County: zipItem.County,
                            State: zipItem.State
                        });
                    }
                });
            }

            // Get state code from FIPS (first 2 digits)
            let stateCodeInfo = null;
            if (stateQuery && countyResults.length > 0) {
                const firstCounty = countyResults[0];
                if (firstCounty.FIPS && firstCounty.FIPS.length >= 2) {
                    stateCodeInfo = {
                        state: firstCounty.State,
                        stateCode: firstCounty.FIPS.substring(0, 2)
                    };
                }
            }

            // Show Red Cross code results
            if (results.length > 0 && (chapterQuery || regionQuery || divisionQuery)) {
                const uniqueResults = [];
                const seen = new Set();
                results.forEach(item => {
                    const key = `${item.Chapter}|${item.Region}|${item.Division}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueResults.push(item);
                    }
                });

                const resultsHtml = uniqueResults.slice(0, 50).map(item => `
                    <div style="padding: 12px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 3px; border-left: 3px solid #DC143C; margin-bottom: 8px;">
                        <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: start;">
                            <div>
                                <div style="font-weight: 600; color: #333; font-size: 0.95em; margin-bottom: 4px;">
                                    ${item.Chapter || 'N/A'}
                                </div>
                                ${item.Region ? `<div style="font-size: 0.85em; color: #666;">${item.Region}</div>` : ''}
                                ${item.Division ? `<div style="font-size: 0.85em; color: #666;">${item.Division}</div>` : ''}
                            </div>
                            <div style="font-size: 0.85em; color: #666;">
                                ${item.Region ? `<div>Region: ${item.Region}</div>` : ''}
                                ${item.Division ? `<div>Division: ${item.Division}</div>` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="margin-bottom: 6px;">
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">ECODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.ECODE || 'N/A'}</div>
                                </div>
                                <div style="margin-bottom: 6px;">
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">RCODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.RCODE || 'N/A'}</div>
                                </div>
                                <div>
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">DCODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.DCODE || 'N/A'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

                document.getElementById('codeResultsContent').innerHTML = resultsHtml;
                document.getElementById('codeResults').style.display = 'block';
            } else {
                document.getElementById('codeResults').style.display = 'none';
            }

            // Show ZIP code results if ZIP was searched
            if (zipQuery) {
                if (zipResults.length > 0) {
                    const zipResultsHtml = zipResults.slice(0, 10).map(item => `
                        <div style="padding: 12px; background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; margin-bottom: 8px;">
                            <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; color: #333; font-size: 0.95em;">
                                        ZIP Code: ${item.Zip}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666; margin-top: 2px;">
                                        ${item.County || 'N/A'} County, ${item.State || 'N/A'}
                                    </div>
                                </div>
                                <div style="font-size: 0.85em; color: #666;">
                                    County FIPS Code
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.3em;">${item.FIPS || 'N/A'}</div>
                                    <div style="font-size: 0.7em; color: #999; margin-top: 2px;">
                                        State: ${item.FIPS ? item.FIPS.substring(0, 2) : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('');
                    
                    document.getElementById('countyResultsContent').innerHTML = zipResultsHtml;
                    document.getElementById('countyResultsSection').style.display = 'block';
                } else {
                    // ZIP not found - show message and don't show other county results
                    document.getElementById('countyResultsContent').innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #999;">
                            <div style="font-size: 1.1em; margin-bottom: 8px;">ZIP Code ${zipQuery} not found</div>
                            <div style="font-size: 0.9em;">This ZIP code is not in our database. Try searching by County Name or FIPS Code instead.</div>
                        </div>
                    `;
                    document.getElementById('countyResultsSection').style.display = 'block';
                    return; // Don't show other county results when ZIP search fails
                }
            }

            // Show county results with state code (only if ZIP was not searched, or ZIP search succeeded)
            if ((countyQuery || stateQuery || fipsQuery) && !zipQuery) {
                let countyResultsHtml = '';
                
                // Show state code if state was searched
                if (stateCodeInfo) {
                    countyResultsHtml += `
                        <div style="padding: 12px; background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; margin-bottom: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; color: #333; font-size: 1em;">
                                        ${stateCodeInfo.state}
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #666;">
                                    State Code (FIPS)
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.4em;">${stateCodeInfo.stateCode}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Show counties
                if (countyResults.length > 0) {
                    countyResultsHtml += countyResults.slice(0, 50).map(item => {
                        const stateCode = item.FIPS && item.FIPS.length >= 2 ? item.FIPS.substring(0, 2) : '';
                        return `
                            <div style="padding: 10px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 3px; border-left: 3px solid #DC143C; margin-bottom: 6px;">
                                <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                    <div>
                                        <div style="font-weight: 600; color: #333; font-size: 0.9em;">
                                            ${item.County || 'N/A'} County
                                        </div>
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        ${item.State || ''}${stateCode ? ` (State Code: ${stateCode})` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">FIPS</div>
                                        <div style="color: #DC143C; font-weight: 700; font-size: 1.2em;">${item.FIPS || 'N/A'}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else if (stateQuery || fipsQuery || countyQuery) {
                    countyResultsHtml += `<div style="padding: 20px; text-align: center; color: #999;">No counties found</div>`;
                }

                if (countyResultsHtml) {
                    document.getElementById('countyResultsContent').innerHTML = countyResultsHtml;
                    document.getElementById('countyResultsSection').style.display = 'block';
                } else {
                    document.getElementById('countyResultsSection').style.display = 'none';
                }
            } else if (!zipQuery) {
                document.getElementById('countyResultsSection').style.display = 'none';
            }
        }

        // Reset all search fields
        function resetSearch() {
            document.getElementById('chapterSearch').value = '';
            document.getElementById('regionSearch').value = '';
            document.getElementById('divisionSearch').value = '';
            document.getElementById('zipSearch').value = '';
            document.getElementById('countySearch').value = '';
            document.getElementById('stateSearch').value = '';
            document.getElementById('fipsSearch').value = '';
            
            // Clear results
            document.getElementById('noResults').style.display = 'block';
            document.getElementById('codeResults').style.display = 'none';
            document.getElementById('countyResultsSection').style.display = 'none';
            document.getElementById('codeResultsContent').innerHTML = '';
            document.getElementById('countyResultsContent').innerHTML = '';
        }

        // Initialize
        updateOptionCards();
        
        // Load built-in database when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadBuiltInDatabase);
        } else {
            // DOM already loaded
            setTimeout(loadBuiltInDatabase, 100);
        }
    </script>
</body>
</html>

