<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Red Cross GIS Tools</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 15px;
            color: #333;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            border-top: 4px solid #DC143C;
        }

        .header {
            background: #DC143C;
            color: white;
            padding: 20px 30px;
            text-align: center;
            border-bottom: 1px solid #b01030;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 0.95em;
            opacity: 0.95;
            font-weight: 300;
        }

        .content {
            padding: 25px 30px;
        }

        .section {
            margin-bottom: 30px;
        }

        .section h2 {
            font-size: 1.3em;
            margin-bottom: 12px;
            color: #DC143C;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .section h2::before {
            content: '';
            width: 3px;
            height: 20px;
            background: #DC143C;
            border-radius: 1px;
        }

        .explanation {
            background: #fafafa;
            padding: 15px 18px;
            border-radius: 3px;
            margin-bottom: 20px;
            border-left: 3px solid #DC143C;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .hierarchy {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin: 20px 0;
        }

        .level {
            background: white;
            padding: 12px 15px;
            border-radius: 3px;
            border-left: 3px solid #DC143C;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            display: flex;
            align-items: center;
            gap: 12px;
            transition: all 0.2s;
        }

        .level:hover {
            transform: translateX(3px);
            box-shadow: 0 2px 6px rgba(220,20,60,0.15);
            border-left-color: #b01030;
        }

        .level-icon {
            font-size: 1.4em;
            width: 35px;
            text-align: center;
        }

        .level-info {
            flex: 1;
        }

        .level-info h3 {
            font-size: 1em;
            margin-bottom: 3px;
            color: #333;
            font-weight: 600;
        }

        .level-info p {
            color: #666;
            font-size: 0.85em;
            line-height: 1.4;
        }

        .arrow {
            font-size: 1em;
            color: #DC143C;
            margin: 0 5px;
            opacity: 0.6;
        }

        .upload-area {
            border: 2px dashed #DC143C;
            border-radius: 3px;
            padding: 25px 20px;
            text-align: center;
            background: #fafafa;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
        }

        .upload-area:hover {
            background: #fff5f5;
            border-color: #b01030;
        }

        .upload-area.dragover {
            background: #ffe8e8;
            border-color: #b01030;
            border-style: solid;
        }

        .upload-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 1em;
            color: #DC143C;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .upload-hint {
            color: #888;
            font-size: 0.85em;
        }

        #fileInput {
            display: none;
        }

        .file-info {
            margin-top: 12px;
            padding: 10px 12px;
            background: #fff5f5;
            border-radius: 3px;
            display: none;
            border-left: 3px solid #DC143C;
        }

        .file-info.show {
            display: block;
        }

        .file-info .filename {
            font-weight: 600;
            color: #DC143C;
            font-size: 0.9em;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .option-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 3px;
            padding: 12px 10px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .option-card:hover {
            border-color: #DC143C;
            transform: translateY(-2px);
            box-shadow: 0 2px 6px rgba(220,20,60,0.15);
        }

        .option-card.selected {
            border-color: #DC143C;
            background: #fff5f5;
        }

        .option-card input[type="checkbox"] {
            width: 16px;
            height: 16px;
            margin-bottom: 6px;
            cursor: pointer;
            accent-color: #DC143C;
        }

        .option-card .icon {
            font-size: 1.5em;
            margin-bottom: 6px;
        }

        .option-card label {
            display: block;
            font-weight: 500;
            color: #333;
            cursor: pointer;
            font-size: 0.9em;
        }

        .process-btn {
            background: #DC143C;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 1em;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 4px rgba(220,20,60,0.3);
            margin: 20px auto;
            display: block;
            font-weight: 500;
        }

        .process-btn:hover {
            background: #b01030;
            box-shadow: 0 3px 6px rgba(220,20,60,0.4);
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #ccc;
            box-shadow: none;
        }

        .progress {
            display: none;
            margin: 20px 0;
        }

        .progress.show {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e0e0e0;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: #DC143C;
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 500;
            font-size: 0.85em;
        }

        .status {
            text-align: center;
            color: #666;
            font-size: 0.85em;
        }

        .results {
            display: none;
            margin-top: 20px;
        }

        .results.show {
            display: block;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .result-card {
            background: #fafafa;
            border-radius: 3px;
            padding: 12px;
            border: 2px solid #e0e0e0;
            transition: all 0.2s;
        }

        .result-card:hover {
            border-color: #DC143C;
            transform: translateY(-2px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .result-card .icon {
            font-size: 1.5em;
            margin-bottom: 6px;
        }

        .result-card .filename {
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
            font-size: 0.9em;
        }

        .result-card .size {
            color: #666;
            font-size: 0.8em;
            margin-bottom: 10px;
        }

        .download-btn {
            background: #DC143C;
            color: white;
            border: none;
            padding: 6px 15px;
            border-radius: 3px;
            cursor: pointer;
            width: 100%;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 500;
        }

        .download-btn:hover {
            background: #b01030;
        }

        .info-badge {
            display: inline-block;
            background: #fff5f5;
            color: #DC143C;
            padding: 3px 8px;
            border-radius: 2px;
            font-size: 0.75em;
            margin: 3px;
            font-weight: 500;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .processing {
            animation: pulse 2s infinite;
        }

        /* Accordion Styles */
        .accordion {
            margin-bottom: 20px;
        }

        .accordion-header {
            background: #f5f5f5;
            border: 2px solid #e0e0e0;
            border-radius: 3px;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.2s;
            user-select: none;
        }

        .accordion-header:hover {
            background: #efefef;
            border-color: #DC143C;
        }

        .accordion-header.active {
            background: #fff5f5;
            border-color: #DC143C;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .accordion-title {
            font-weight: 600;
            color: #333;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            border: 2px solid #e0e0e0;
            border-top: none;
            border-bottom-left-radius: 3px;
            border-bottom-right-radius: 3px;
        }

        .accordion-content.active {
            border-color: #DC143C;
        }

        .accordion-content-inner {
            padding: 20px;
        }
    </style>
    <!-- Built-in Code Database -->
    <script src="lookup_data.js"></script>
    <!-- Comprehensive ZIP Code Database (33K ZIPs, 99%+ US coverage) -->
    <script src="zip_to_fips_comprehensive.js"></script>
    <!-- State Name Mapping -->
    <script src="state_names.js"></script>
    <!-- Leaflet for map preview -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¥ Red Cross GIS Tools</h1>
            <p>6 powerful tools for Red Cross data processing, geographic analysis, and visualization</p>
        </div>

        <div class="content">
            <!-- Tab Navigation -->
            <div class="tabs" style="display: flex; gap: 10px; margin-bottom: 25px; border-bottom: 2px solid #e0e0e0;">
                <button class="tab-btn active" onclick="showTab('lookup')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üîç Code Lookup Tool
                </button>
                <button class="tab-btn" onclick="showTab('rollup')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üìä CSV Roll-Up
                </button>
                <button class="tab-btn" onclick="showTab('create')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üó∫Ô∏è Create GeoJSON
                </button>
                <button class="tab-btn" onclick="showTab('orgler')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üîó Orgler URL
                </button>
                <button class="tab-btn" onclick="showTab('popup')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üìã Pop-up Creator
                </button>
                <button class="tab-btn" onclick="showTab('geocoder')" style="padding: 10px 20px; background: none; border: none; border-bottom: 3px solid transparent; cursor: pointer; font-weight: 500; color: #666; transition: all 0.2s;">
                    üó∫Ô∏è Mapbox Geocoder
                </button>
            </div>

            <!-- Code Lookup Tab -->
            <div id="lookupTab" class="tab-content">

            <!-- Collapsible Explanation Section -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('lookupAccordion')">
                    <div class="accordion-title">
                        <span>‚ÑπÔ∏è</span>
                        <span>About This Tool - Why Use Codes?</span>
                    </div>
                    <div class="accordion-icon">‚ñº</div>
                </div>
                <div id="lookupAccordion" class="accordion-content">
                    <div class="accordion-content-inner">
            <div class="section">
                <h2>Red Cross Code Lookup</h2>
                <div class="explanation">
                    <p>Built-in database of all Red Cross chapters, regions, divisions, and counties. Search by name to find ECODE, RCODE, DCODE, and FIPS codes instantly.</p>
                </div>

                <h2>Why Use Codes Instead of Names?</h2>
                <div class="explanation" style="background: #fff5f5; border-left: 3px solid #DC143C;">
                    <p style="font-weight: 600; margin-bottom: 12px; color: #DC143C;">Codes are standardized, unique identifiers that eliminate ambiguity and spelling errors.</p>
                    
                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üìç ZIP Codes (5-digit)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> United States Postal Service ZIP Code Tabulation Areas (ZCTA5)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> 5 digits (e.g., <code>33019</code>, <code>02134</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Every ZIP code is unique. "Miami" could refer to the city, county, or multiple ZIP codes. <code>33101</code> is unambiguous.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üèõÔ∏è FIPS Codes (5-digit)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Federal Information Processing Standards codes for counties</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> 5 digits = State FIPS (2) + County FIPS (3), e.g., <code>12011</code> = Florida (12) + Broward County (011)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> "Dallas" could be Dallas County, TX (<code>48113</code>) or Dallas County, AL (<code>01047</code>). FIPS codes are unique nationwide and never change.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üìö ECODE (Chapter Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross chapters</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Numeric code (e.g., <code>1019</code>, <code>38300</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> "Red Cross of Kentucky" vs "American Red Cross Kentucky Region" vs "ARC Kentucky" - all refer to the same chapter, but <code>1019</code> is always correct.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üåç RCODE (Region Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross regions</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Alphanumeric (e.g., <code>01R04</code>, <code>38R28</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Region names change over time, but codes remain stable. "Southeast Region" might become "Southeast and Caribbean Division" - the code stays the same.</p>
                    </div>

                    <div style="margin: 15px 0;">
                        <h3 style="font-size: 1em; margin-bottom: 8px; color: #333;">üåé DCODE (Division Code)</h3>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>What:</strong> Unique identifier for Red Cross divisions</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Format:</strong> Alphanumeric (e.g., <code>D25</code>, <code>D27</code>)</p>
                        <p style="font-size: 0.9em; margin-bottom: 8px;"><strong>Why better:</strong> Division names are long and can be abbreviated differently. <code>D25</code> is always "Southeast and Caribbean Division" regardless of how it's written.</p>
                    </div>

                    <div style="margin-top: 20px; padding: 12px; background: #f0f0f0; border-radius: 3px;">
                        <p style="font-size: 0.9em; margin: 0;"><strong>üí° Key Benefits:</strong></p>
                        <ul style="font-size: 0.85em; margin: 8px 0 0 20px; padding: 0;">
                            <li>No spelling variations (Jefferson vs Jeffersons vs Jefferson County)</li>
                            <li>No ambiguity (Dallas city vs Dallas County vs Dallas Parish)</li>
                            <li>Standardized format (always 5 digits for FIPS, always consistent)</li>
                            <li>Never change (names change, codes stay the same)</li>
                            <li>Perfect for joins (codes match exactly, names require fuzzy matching)</li>
                            <li>International standards (FIPS is federal standard, ZIP is USPS standard)</li>
                        </ul>
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>

            <!-- Search Tool Section -->
            <div class="section">
                    <div style="display: grid; grid-template-columns: 350px 1fr; gap: 30px;">
                        <!-- Left: Search Boxes -->
                        <div style="display: flex; flex-direction: column; gap: 20px;">
                            <button onclick="resetSearch()"
                                    style="padding: 10px 20px; background: #DC143C; color: white; border: none; border-radius: 3px; font-weight: 600; font-size: 0.9em; cursor: pointer; margin-bottom: 10px; transition: background 0.2s;"
                                    onmouseover="this.style.background='#b01030'"
                                    onmouseout="this.style.background='#DC143C'">
                                üîÑ Reset All Searches
                            </button>
                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Chapter Name or ECODE</label>
                                <input type="text" id="chapterSearch" placeholder="e.g., ARC serving Mid Alabama or 1019"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Region Name or RCODE</label>
                                <input type="text" id="regionSearch" placeholder="e.g., Alabama Region or 01R04"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">Division Name or DCODE</label>
                                <input type="text" id="divisionSearch" placeholder="e.g., Southeast Division or D25"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div style="margin-top: 15px; padding-top: 15px; border-top: 2px solid #e0e0e0;">
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">ZIP Code</label>
                                <input type="text" id="zipSearch" placeholder="e.g., 33704"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">County Name</label>
                                <input type="text" id="countySearch" placeholder="e.g., Broward"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">State (shows state code + counties)</label>
                                <input type="text" id="stateSearch" placeholder="e.g., FL or Florida"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>

                            <div>
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333; font-size: 0.9em;">FIPS Code (5-digit: State+County)</label>
                                <input type="text" id="fipsSearch" placeholder="e.g., 12011 (FL=12, Broward=011)"
                                       style="width: 100%; padding: 8px 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;"
                                       oninput="searchCodes()">
                            </div>
                        </div>

                        <!-- Right: Results -->
                        <div id="resultsPanel" style="min-height: 400px; padding: 20px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;">
                            <div id="noResults" style="text-align: center; padding: 40px; color: #999;">
                                <div style="font-size: 3em; margin-bottom: 15px;">üîç</div>
                                <div style="font-size: 1.1em; font-weight: 500;">Enter a search term to find codes</div>
                                <div style="font-size: 0.9em; margin-top: 8px; color: #bbb;">Search by Chapter, Region, Division, County, State, or FIPS</div>
                            </div>

                            <div id="codeResults" style="display: none;">
                                <h3 style="font-size: 1.1em; margin-bottom: 15px; color: #DC143C; border-bottom: 2px solid #DC143C; padding-bottom: 6px;">Red Cross Codes</h3>
                                <div id="codeResultsContent" style="display: flex; flex-direction: column; gap: 0;"></div>
                            </div>

                            <div id="countyResultsSection" style="display: none; margin-top: 25px;">
                                <h3 style="font-size: 1.1em; margin-bottom: 15px; color: #DC143C; border-bottom: 2px solid #DC143C; padding-bottom: 6px;">County & FIPS Codes</h3>
                                <div id="countyResultsContent" style="display: flex; flex-direction: column; gap: 0;"></div>
                            </div>
                        </div>
                    </div>
            </div>
            </div>

            <!-- CSV Roll-Up Tab -->
            <div id="rollupTab" class="tab-content" style="display: none;">

                <!-- Collapsible Explanation Section -->
                <div class="accordion">
                    <div class="accordion-header" onclick="toggleAccordion('rollupAccordion')">
                        <div class="accordion-title">
                            <span>‚ÑπÔ∏è</span>
                            <span>About CSV Roll-Up Tool</span>
                        </div>
                        <div class="accordion-icon">‚ñº</div>
                    </div>
                    <div id="rollupAccordion" class="accordion-content">
                        <div class="accordion-content-inner">
                            <div class="explanation">
                                <p style="font-size: 1.05em; color: #333; margin-bottom: 15px;"><strong>Turn raw ZIP-level data into multi-level insights in seconds</strong></p>

                                <div style="background: #fff; border: 2px solid #DC143C; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                                    <p style="margin-bottom: 10px; font-weight: 600; color: #DC143C;">üì§ INPUT: Your raw data</p>
                                    <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
                                        ZIP, Incidents, Revenue<br>
                                        10001, 5, 1250<br>
                                        10002, 3, 890<br>
                                        10003, 7, 2100
                                    </div>
                                </div>

                                <div style="background: #fff; border: 2px solid #10b981; border-radius: 8px; padding: 15px;">
                                    <p style="margin-bottom: 10px; font-weight: 600; color: #10b981;">üì• OUTPUT: Complete hierarchy at all 5 levels</p>
                                    <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.85em;">
                                        ZIP, County, DCODE, Incidents (ZIP), Incidents (Division)...<br>
                                        10001, "New York, NY", D27, 5, 649<br>
                                        <span style="color: #10b981;">‚Ü≥ Auto-calculated Division totals</span><br>
                                        <span style="color: #10b981;">‚Ü≥ Auto-added FIPS, ECODE, RCODE, DCODE</span>
                                    </div>
                                </div>

                                <div style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 4px solid #f59e0b; border-radius: 6px;">
                                    <p style="margin: 0; font-weight: 600; color: #92400e;">‚ö° Why this is powerful:</p>
                                    <ul style="margin: 8px 0 0 20px; color: #92400e;">
                                        <li>One upload creates data for <strong>all 5 geographic levels</strong></li>
                                        <li>Skip Excel pivot tables and manual aggregation</li>
                                        <li>Instantly ready for Tab 3 ‚Üí create Division/Region maps</li>
                                        <li>100% Red Cross hierarchy compliance (3,162 counties, 226 chapters)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Upload Section -->
                <div class="section">
                    <h2>Upload CSV File</h2>
                    <div class="upload-area" id="rollupUploadArea" style="border: 2px dashed #DC143C; border-radius: 3px; padding: 40px; text-align: center; cursor: pointer; background: #fafafa; transition: all 0.2s;">
                        <div style="font-size: 2.5em; margin-bottom: 10px; color: #DC143C;">üìÅ</div>
                        <p style="font-size: 1.1em; margin-bottom: 5px; font-weight: 500;">Drop CSV file here or click to browse</p>
                        <p style="font-size: 0.85em; color: #666;">Upload row-level data with ZIP or County codes</p>
                    </div>
                    <input type="file" id="rollupFileInput" accept=".csv" style="display: none;">

                    <div id="rollupFileInfo" class="file-info" style="margin-top: 15px; padding: 12px; background: #f0f8ff; border-left: 3px solid #DC143C; border-radius: 3px; display: none;">
                        <span style="font-weight: 500;">üìÑ File: </span>
                        <span id="rollupFileName"></span>
                        <span id="rollupFileSize" style="color: #666; margin-left: 10px;"></span>
                    </div>
                </div>

                <!-- Column Detection Section -->
                <div id="rollupColumnDetectionSection" class="section" style="display: none;">
                    <h2>Configure Aggregation</h2>

                    <div style="background: #f0f8ff; padding: 15px; border-radius: 3px; margin-bottom: 20px; border-left: 3px solid #DC143C;">
                        <p style="font-weight: 500; margin-bottom: 8px;">Detected Input Level:</p>
                        <p id="rollupDetectedLevelText" style="font-size: 1.1em; color: #DC143C;"></p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <p style="font-weight: 500; margin-bottom: 10px;">Select metrics to aggregate:</p>
                        <div id="rollupAggregationFields" style="display: flex; flex-direction: column; gap: 10px;">
                            <!-- Aggregation field checkboxes will be inserted here -->
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <p style="font-weight: 500; margin-bottom: 10px;">Select geographic levels to output:</p>
                        <div id="rollupOutputLevels" style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <!-- Level checkboxes will be inserted here -->
                        </div>
                    </div>

                    <button id="rollupProcessBtn" style="width: 100%; padding: 15px; background: #DC143C; color: white; border: none; border-radius: 3px; font-size: 1.1em; cursor: pointer; font-weight: 500; transition: all 0.2s;">
                        üöÄ Process and Generate CSV
                    </button>
                </div>

                <!-- Progress Section -->
                <div id="rollupProgressSection" class="section" style="display: none;">
                    <h2>Processing...</h2>
                    <div style="background: #f5f5f5; border-radius: 3px; overflow: hidden; height: 30px; margin-bottom: 10px;">
                        <div id="rollupProgressFill" style="height: 100%; background: linear-gradient(90deg, #DC143C, #ff4060); width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 500; font-size: 0.9em;"></div>
                    </div>
                    <p id="rollupStatus" style="color: #666; font-size: 0.9em; text-align: center;"></p>
                </div>

                <!-- Results Section -->
                <div id="rollupResultSection" class="section" style="display: none;">
                    <h2>Download Results</h2>
                    <div id="rollupResultGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 15px;">
                        <!-- Download buttons will be inserted here -->
                    </div>
                </div>

            </div>

            <!-- Create GeoJSON Tab -->
            <div id="createTab" class="tab-content" style="display: none;">

            <!-- Collapsible Explanation Section -->
            <div class="accordion">
                <div class="accordion-header" onclick="toggleAccordion('createAccordion')">
                    <div class="accordion-title">
                        <span>‚ÑπÔ∏è</span>
                        <span>How It Works - Geographic Hierarchy Explained</span>
                    </div>
                    <div class="accordion-icon">‚ñº</div>
                </div>
                <div id="createAccordion" class="accordion-content">
                    <div class="accordion-content-inner">
            <div class="section">
                <h2>What This Does</h2>
                <div class="explanation">
                    <p>This tool takes your CSV file with geographic identifiers (ZIP codes, FIPS codes, etc.) and automatically creates GeoJSON files at multiple aggregation levels. Perfect for creating choropleth maps in ArcGIS Online, web applications, or data visualization tools.</p>
                </div>

                <h2>Geographic Hierarchy</h2>
                <div class="hierarchy">
                    <div class="level">
                        <div class="level-icon">üì¶</div>
                        <div class="level-info">
                            <h3>ZIP Codes</h3>
                            <p>Most granular level - includes all original data fields. Perfect for detailed analysis.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üèõÔ∏è</div>
                        <div class="level-info">
                            <h3>Counties</h3>
                            <p>Aggregated from ZIP codes - includes county totals and hierarchy information.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üìö</div>
                        <div class="level-info">
                            <h3>Chapters</h3>
                            <p>Aggregated from counties - boundaries created by merging county polygons.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üåç</div>
                        <div class="level-info">
                            <h3>Regions</h3>
                            <p>Aggregated from chapters - larger geographic areas with regional totals.</p>
                        </div>
                    </div>
                    <div class="arrow">‚Üì</div>
                    <div class="level">
                        <div class="level-icon">üåé</div>
                        <div class="level-info">
                            <h3>Divisions</h3>
                            <p>Highest level - aggregated from regions. Perfect for high-level overviews.</p>
                        </div>
                    </div>
                </div>
            </div>
                    </div>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="section">
                <h2>Step 1: Upload Your CSV File</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">üì§</div>
                    <div class="upload-text">Drop your CSV file here or click to browse</div>
                    <div class="upload-hint">Your CSV can have individual row-level data (multiple entries per ZIP/County) or pre-aggregated data<br><small style="color: #DC143C; font-weight: 500;">üí° Tip: This tool will automatically aggregate your data by ZIP or County</small></div>
                    <input type="file" id="fileInput" accept=".csv">
                </div>
                <div class="file-info" id="fileInfo">
                    <span class="filename" id="fileName"></span>
                    <span id="fileSize"></span>
                </div>
            </div>

            <!-- Column Detection Section -->
            <div class="section" id="columnDetectionSection" style="display: none;">
                <h2>Step 2: Configure Data Aggregation</h2>

                <!-- Granularity Level -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Input Data Level</h3>
                    <div id="detectedLevel" style="background: #fff5f5; padding: 12px; border-left: 3px solid #DC143C; border-radius: 3px; margin-bottom: 12px;">
                        <strong>Auto-detected:</strong> <span id="detectedLevelText">Analyzing...</span>
                    </div>
                    <div style="display: flex; gap: 15px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 15px; border: 2px solid #e0e0e0; border-radius: 3px; background: white;">
                            <input type="radio" name="granularity" value="zip" id="granularityZip" style="accent-color: #DC143C;">
                            <span>üì¶ ZIP Code Level (detailed)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 10px 15px; border: 2px solid #e0e0e0; border-radius: 3px; background: white;">
                            <input type="radio" name="granularity" value="county" id="granularityCounty" style="accent-color: #DC143C;">
                            <span>üèõÔ∏è County Level (aggregated)</span>
                        </label>
                    </div>
                </div>

                <!-- Aggregation Fields -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Select Fields to Aggregate</h3>
                    <div class="explanation" style="margin-bottom: 15px;">
                        <p><strong>COUNT</strong> = Count number of rows | <strong>SUM</strong> = Add up values in a column</p>
                    </div>
                    <div id="aggregationFields" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>

                <!-- Column Mapping -->
                <div style="margin-bottom: 20px;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #333;">Geographic Columns Detected</h3>
                    <div id="columnMapping" style="background: #fafafa; padding: 15px; border-radius: 3px; border: 1px solid #e0e0e0;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- Options Section -->
            <div class="section" id="outputLevelsSection">
                <h2>Step 3: Select Output Levels</h2>
                <p style="margin-bottom: 12px; color: #666; font-size: 0.9em;">Choose which GeoJSON files you want to create (with hierarchical roll-ups):</p>
                <div class="options">
                    <div class="option-card" data-level="zip">
                        <input type="checkbox" id="optZip" checked>
                        <div class="icon">üì¶</div>
                        <label for="optZip">ZIP Codes</label>
                        <div class="info-badge">All fields</div>
                    </div>
                    <div class="option-card" data-level="county">
                        <input type="checkbox" id="optCounty" checked>
                        <div class="icon">üèõÔ∏è</div>
                        <label for="optCounty">Counties</label>
                        <div class="info-badge">Aggregated</div>
                    </div>
                    <div class="option-card" data-level="chapter">
                        <input type="checkbox" id="optChapter">
                        <div class="icon">üìö</div>
                        <label for="optChapter">Chapters</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                    <div class="option-card" data-level="region">
                        <input type="checkbox" id="optRegion">
                        <div class="icon">üåç</div>
                        <label for="optRegion">Regions</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                    <div class="option-card" data-level="division">
                        <input type="checkbox" id="optDivision">
                        <div class="icon">üåé</div>
                        <label for="optDivision">Divisions</label>
                        <div class="info-badge">Dissolved</div>
                    </div>
                </div>
            </div>

            <!-- Aggregation Summary -->
            <div class="section" id="aggregationSummary" style="display: none;">
                <div style="background: #fff5f5; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                    <h3 style="font-size: 1em; margin-bottom: 10px; color: #DC143C;">üìä Aggregation Summary</h3>
                    <div id="summaryContent" style="font-size: 0.9em; line-height: 1.6;"></div>
                </div>
            </div>

            <!-- Process Button -->
            <button class="process-btn" id="processBtn" disabled>üöÄ Aggregate Data & Create GeoJSON Files</button>

            <!-- Progress Section -->
            <div class="progress" id="progress">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <div class="status" id="status">Ready to process...</div>
            </div>

            <!-- Preview Map Section -->
            <div class="results" id="previewSection" style="display: none;">
                <h2>Map Preview</h2>
                <div style="margin-bottom: 15px;">
                    <label for="previewLevel" style="font-weight: 600; margin-right: 10px;">View Level:</label>
                    <select id="previewLevel" style="padding: 8px 12px; border: 2px solid #e0e0e0; border-radius: 3px;">
                        <option value="zip">ZIP Codes</option>
                        <option value="county">Counties</option>
                        <option value="chapter">Chapters</option>
                        <option value="region">Regions</option>
                        <option value="division">Divisions</option>
                    </select>
                </div>
                <div id="map" style="height: 500px; border: 2px solid #e0e0e0; border-radius: 3px;"></div>
            </div>

            <!-- Results Section -->
            <div class="results" id="results">
                <h2>Generated Files</h2>
                <div class="result-grid" id="resultGrid"></div>
            </div>
            </div>

            <!-- Orgler URL Creator Tab -->
            <div id="orglerTab" class="tab-content" style="display: none;">
                <div class="section">
                    <div class="explanation">
                        <p>Convert Power BI URLs to Orgler format for embedding in Story Maps and RCView dashboards.</p>
                    </div>

                    <div style="margin-top: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Power BI URL:</label>
                        <textarea id="orglerPowerbiUrl" rows="3" placeholder="Paste your Power BI report URL here"
                                  style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; font-family: monospace; background: white; color: #333;">https://app.powerbi.com/groups/me/reports/ddd5cb5a-9b44-407f-aa6d-1b291b5ba61a</textarea>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">A sample URL is pre-filled. Click "Convert to Orgler URL" to see how it works, or replace it with your own Power BI URL.</div>
                    </div>

                    <button onclick="convertToOrglerTool()" class="process-btn" style="margin-top: 20px;">
                        Convert to Orgler URL
                    </button>

                    <div id="orglerResultDiv" style="display: none; margin-top: 25px;">
                        <div style="background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; padding: 20px;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Converted Orgler URL:</h3>
                            <textarea id="orglerOutputText" rows="4" readonly
                                      style="width: 100%; font-family: monospace; font-size: 0.85em; background: white; color: #333; border: 2px solid #e0e0e0; padding: 10px; border-radius: 3px; margin-bottom: 15px;"></textarea>
                            <button onclick="copyOrglerUrlTool()" class="process-btn" style="width: 100%; margin: 0; background: #4CAF50;">
                                Copy URL
                            </button>
                        </div>
                    </div>

                    <div class="explanation" style="margin-top: 25px; background: #fff5f5; border-left: 3px solid #DC143C;">
                        <h3 style="font-size: 1em; margin-bottom: 10px; color: #DC143C;">How to Use:</h3>
                        <ol style="margin: 10px 0; padding-left: 20px; font-size: 0.9em; line-height: 1.6;">
                            <li>Click "Convert to Orgler URL" to see the sample conversion, or</li>
                            <li>Replace the sample URL with your own Power BI report URL</li>
                            <li>Click "Convert to Orgler URL"</li>
                            <li>Copy the generated URL and use it in your Story Map or RCView embedding code</li>
                        </ol>
                        <p style="font-size: 0.85em; margin-top: 10px; font-style: italic; color: #666;">
                            <strong>Note:</strong> Orgler URLs are optimized for embedding Power BI reports in ArcGIS Story Maps and RCView dashboards.
                        </p>
                    </div>
                </div>
            </div>

            <!-- ArcGIS Pop-up Creator Tab -->
            <div id="popupTab" class="tab-content" style="display: none;">
                <div class="section">
                    <div class="explanation">
                        <p>Extract field names from an ArcGIS Online feature layer and generate inline CSS + HTML pop-up templates ready to paste into ArcGIS Experience Builder, Map Viewer, or Dashboards.</p>
                    </div>

                    <div style="background: #e8f5e9; border-left: 4px solid #4CAF50; padding: 15px; border-radius: 3px; margin: 20px 0;">
                        <h3 style="margin: 0 0 10px 0; color: #2e7d32; font-size: 16px;">How to Use:</h3>
                        <ol style="margin: 5px 0 0 0; padding-left: 20px; font-size: 13px; color: #2e7d32; line-height: 1.6;">
                            <li>Open your ArcGIS FeatureServer REST page (e.g., <code style="background: #fff; padding: 2px 6px; border-radius: 3px; font-size: 12px;">.../FeatureServer/0</code>)</li>
                            <li>Scroll down to the <strong>Fields:</strong> section</li>
                            <li>Copy all the field definitions (the entire list showing field names, types, and aliases)</li>
                            <li>Paste them into the box below</li>
                        </ol>
                    </div>

                    <div style="margin-top: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Paste Field Definitions from ArcGIS REST Page:</label>
                        <textarea id="popupToolFieldsInput" rows="12"
                                  placeholder="Division (type: esriFieldTypeString, alias: Division, SQL Type: sqlTypeNVarchar, length: 4000, nullable: true, editable: true)&#10;DCODE (type: esriFieldTypeString, alias: DCODE, SQL Type: sqlTypeNVarchar, length: 4000, nullable: true, editable: true)&#10;F2022 (type: esriFieldTypeSingle, alias: 2022, SQL Type: sqlTypeReal, nullable: true, editable: true)&#10;..."
                                  style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.85em; font-family: monospace; background: white; color: #333;"></textarea>
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            <strong>Example format:</strong> <code style="background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-size: 12px;">FieldName (type: esriFieldTypeString, alias: Display Name, ...)</code>
                        </div>
                        <button onclick="parsePopupFieldDefinitions()" class="process-btn" style="margin-top: 15px;">
                            Parse Fields
                        </button>
                    </div>

                    <div id="popupToolFieldsContainer" style="display: none; margin-top: 25px;">
                        <div style="background: #fafafa; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Select Fields to Include</h3>

                            <input type="text" id="popupToolFieldFilter" placeholder="Filter fields..."
                                   style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 3px; margin-bottom: 15px; font-size: 0.9em;"
                                   oninput="filterPopupToolFields()">

                            <div id="popupToolFieldList" style="max-height: 300px; overflow-y: auto; border: 1px solid #e0e0e0; padding: 10px; background: white; border-radius: 3px;">
                            </div>

                            <div style="margin-top: 15px; font-size: 0.85em; color: #666;">
                                <span id="popupToolFieldCount">0</span> fields selected
                            </div>
                        </div>

                        <div style="margin-top: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Pop-up Title:</label>
                            <input type="text" id="popupToolTitle" placeholder="e.g., ARC Biomed Zip Code Summary"
                                   style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white; color: #333;">
                        </div>

                        <div style="margin-top: 20px;">
                            <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Field Grouping (optional):</label>
                            <textarea id="popupToolGroups" rows="3" placeholder="Group 1: County, Region, Chapter&#10;Group 2: 2025 Total, Grand Total"
                                      style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; font-family: monospace; background: white; color: #333;"></textarea>
                            <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Enter field names separated by commas, one group per line. Fields will be separated by horizontal rules.</div>
                        </div>

                        <button onclick="generatePopupToolHTML()" class="process-btn" style="margin-top: 20px;">
                            Generate Pop-up HTML
                        </button>
                    </div>

                    <div id="popupToolResult" style="display: none; margin-top: 25px;">
                        <div style="background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; padding: 20px;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Generated Pop-up HTML:</h3>

                            <div id="popupToolPreview" style="background: white; padding: 15px; border: 1px solid #e0e0e0; border-radius: 3px; margin-bottom: 15px; min-height: 100px;">
                            </div>

                            <textarea id="popupToolOutput" rows="10" readonly
                                      style="width: 100%; font-family: monospace; font-size: 0.85em; background: white; color: #333; border: 2px solid #e0e0e0; padding: 10px; border-radius: 3px; margin-bottom: 15px;"></textarea>

                            <div style="display: flex; gap: 10px;">
                                <button onclick="copyPopupToolHTML()" class="process-btn" style="flex: 1; margin: 0; background: #4CAF50;">
                                    Copy HTML
                                </button>
                                <button onclick="downloadPopupToolHTML()" class="process-btn" style="flex: 1; margin: 0; background: #2196F3;">
                                    Download as .html
                                </button>
                                <button onclick="downloadPopupToolTXT()" class="process-btn" style="flex: 1; margin: 0; background: #2196F3;">
                                    Download as .txt
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="explanation" style="margin-top: 25px; background: #fff5f5; border-left: 3px solid #DC143C;">
                        <h3 style="font-size: 1em; margin-bottom: 10px; color: #DC143C;">Quick Reference:</h3>
                        <p style="font-size: 0.9em; margin-bottom: 10px;"><strong>After parsing fields:</strong></p>
                        <ol style="margin: 10px 0; padding-left: 20px; font-size: 0.9em; line-height: 1.6;">
                            <li>Select which fields to include in your pop-up</li>
                            <li>Optionally add a pop-up title</li>
                            <li>Optionally group related fields together (e.g., all 2022-2025 fields in one group)</li>
                            <li>Click "Generate Pop-up HTML"</li>
                            <li>Copy the generated HTML and paste it into ArcGIS Experience Builder or Map Viewer pop-up editor</li>
                        </ol>
                        <p style="font-size: 0.85em; margin-top: 10px; font-style: italic; color: #666;">
                            <strong>Note:</strong> Generated HTML uses inline CSS matching American Red Cross color standards (#c8102e) and compact Economist-style typography.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Mapbox Geocoder Tab -->
            <div id="geocoderTab" class="tab-content" style="display: none;">
                <div class="section">
                    <h2>Mapbox Geocoder</h2>
                    <div class="explanation">
                        <p>Geocode addresses from a CSV file using Mapbox Geocoding API. Upload your CSV with address columns, and get back a GeoJSON file with coordinates for each address.</p>
                    </div>

                    <div style="margin-top: 20px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Mapbox Access Token:</label>
                        <input type="password" id="geocoderMapboxToken" placeholder="pk.eyJ1IjoieW91cnVzZXJuYW1lIiwiYSI6ImNs..."
                               style="width: 100%; padding: 10px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; font-family: monospace; background: white; color: #333;">
                        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">
                            Get your free token at <a href="https://account.mapbox.com/access-tokens/" target="_blank" style="color: #DC143C;">https://account.mapbox.com/access-tokens/</a>
                        </div>
                    </div>

                    <div style="margin-top: 25px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Upload CSV File:</label>
                        <div style="border: 2px dashed #e0e0e0; border-radius: 3px; padding: 30px; text-align: center; background: #fafafa; cursor: pointer; transition: all 0.2s;"
                             id="geocoderDropZone"
                             onmouseover="this.style.borderColor='#DC143C'; this.style.background='#fff5f5'"
                             onmouseout="this.style.borderColor='#e0e0e0'; this.style.background='#fafafa'"
                             onclick="document.getElementById('geocoderFileInput').click()">
                            <div style="font-size: 2em; margin-bottom: 10px;">üì§</div>
                            <div style="font-weight: 600; color: #333; margin-bottom: 5px;">Drop your CSV file here or click to browse</div>
                            <div style="font-size: 0.85em; color: #666;">Your CSV should have address columns (street, city, state, zip, etc.)</div>
                        </div>
                        <input type="file" id="geocoderFileInput" accept=".csv" style="display: none;" onchange="handleGeocoderFileSelect(event)">
                        <div id="geocoderFileName" style="margin-top: 10px; font-size: 0.9em; color: #333; font-weight: 500;"></div>
                    </div>

                    <div id="geocoderColumnSelector" style="display: none; margin-top: 25px;">
                        <div style="background: #fafafa; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Select Address Columns</h3>
                            <div id="geocoderColumnOptions" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            </div>
                        </div>
                    </div>

                    <div id="geocoderGeocodingOptions" style="display: none; margin-top: 20px;">
                        <div style="background: #fafafa; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Geocoding Options</h3>

                            <div id="geocoderCoordinateWarning" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 3px; padding: 10px; margin-bottom: 15px;">
                                <strong style="color: #856404;">Existing Coordinates Detected</strong>
                                <p style="margin: 5px 0; font-size: 0.9em; color: #856404;">Your CSV already has coordinate columns. Choose how to handle them:</p>
                                <div style="margin-top: 10px;">
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 8px;">
                                        <input type="radio" name="geocoderCoordinateHandling" value="replace" checked>
                                        <span><strong>Replace</strong> - Remove old coordinates, use only geocoded coordinates (Recommended for ArcGIS)</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                        <input type="radio" name="geocoderCoordinateHandling" value="keep">
                                        <span><strong>Keep Both</strong> - Keep original + add geocoded (may confuse ArcGIS)</span>
                                    </label>
                                </div>
                            </div>

                            <div style="margin-bottom: 15px;">
                                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                    <input type="checkbox" id="geocoderIncludeOriginal" checked>
                                    <span>Include original CSV columns in output</span>
                                </label>
                            </div>
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; font-weight: 600; margin-bottom: 6px; color: #333;">Country Code (optional):</label>
                                <input type="text" id="geocoderCountryCode" placeholder="US" maxlength="2"
                                       style="width: 100px; padding: 8px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em;">
                                <div style="font-size: 0.85em; color: #666; margin-top: 5px;">ISO 3166-1 alpha-2 code (e.g., US, CA, MX)</div>
                            </div>
                        </div>
                    </div>

                    <button id="geocoderGeocodeBtn" onclick="startGeocoderGeocoding()" class="process-btn" style="margin-top: 20px; display: none;">
                        Start Geocoding
                    </button>

                    <div id="geocoderProgress" style="display: none; margin-top: 20px;">
                        <div style="background: #fafafa; padding: 15px; border-radius: 3px; border-left: 3px solid #DC143C;">
                            <div style="font-weight: 600; color: #DC143C; margin-bottom: 10px;">Geocoding Progress</div>
                            <div style="background: white; height: 25px; border-radius: 3px; overflow: hidden; border: 1px solid #e0e0e0;">
                                <div id="geocoderProgressBar" style="background: #DC143C; height: 100%; width: 0%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-size: 0.85em; font-weight: 600;">0%</div>
                            </div>
                            <div id="geocoderProgressText" style="margin-top: 10px; font-size: 0.9em; color: #666;">Ready to process...</div>
                        </div>
                    </div>

                    <div id="geocoderResults" style="display: none; margin-top: 25px;">
                        <div style="background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; padding: 20px;">
                            <h3 style="margin-top: 0; color: #DC143C; margin-bottom: 15px;">Geocoding Complete</h3>
                            <div id="geocoderResultsSummary" style="margin-bottom: 15px; font-size: 0.9em; color: #333;"></div>

                            <div style="display: flex; gap: 10px;">
                                <button onclick="downloadGeocoderGeoJSON()" class="process-btn" style="flex: 1; margin: 0; background: #4CAF50;">
                                    Download GeoJSON
                                </button>
                                <button onclick="downloadGeocoderCSV()" class="process-btn" style="flex: 1; margin: 0; background: #2196F3;">
                                    Download CSV with Coordinates
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="explanation" style="margin-top: 25px; background: #fff5f5; border-left: 3px solid #DC143C;">
                        <h3 style="font-size: 1em; margin-bottom: 10px; color: #DC143C;">How to Use:</h3>
                        <ol style="margin: 10px 0; padding-left: 20px; font-size: 0.9em; line-height: 1.6;">
                            <li>Get a free Mapbox access token from <a href="https://account.mapbox.com/access-tokens/" target="_blank" style="color: #DC143C;">mapbox.com</a></li>
                            <li>Paste your Mapbox access token in the field above</li>
                            <li>Upload a CSV file with address columns (street, city, state, zip, etc.)</li>
                            <li>Select which columns contain address information</li>
                            <li>Optionally specify a country code to improve accuracy</li>
                            <li>Click "Start Geocoding" to process your addresses</li>
                            <li>Download the resulting GeoJSON or CSV file with coordinates</li>
                        </ol>
                        <p style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #e0e0e0;">
                            <strong>Note:</strong> Mapbox offers free geocoding up to 100,000 requests per month. Addresses are geocoded one at a time to respect rate limits.
                        </p>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <script>
        // File handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileSize = document.getElementById('fileSize');
        const processBtn = document.getElementById('processBtn');
        const progress = document.getElementById('progress');
        const progressFill = document.getElementById('progressFill');
        const status = document.getElementById('status');
        const results = document.getElementById('results');
        const resultGrid = document.getElementById('resultGrid');

        let selectedFile = null;
        let csvData = null;
        let detectedColumns = null;
        let aggregationConfig = {
            fields: [],
            granularity: null
        };

        // Geographic boundary data (loaded on demand)
        let geoBoundaries = {
            zip: null,
            county: null,
            chapter: null,
            region: null,
            division: null
        };

        // Generated GeoJSON results
        let generatedGeoJSON = {
            zip: null,
            county: null,
            chapter: null,
            region: null,
            division: null
        };

        // Leaflet map
        let previewMap = null;
        let currentLayer = null;

        // Upload area click
        uploadArea.addEventListener('click', () => fileInput.click());

        // File input change
        fileInput.addEventListener('change', (e) => {
            handleFile(e.target.files[0]);
        });

        // Drag and drop
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            handleFile(e.dataTransfer.files[0]);
        });

        function handleFile(file) {
            if (!file || !file.name.endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            selectedFile = file;
            fileName.textContent = file.name;
            fileSize.textContent = `(${(file.size / 1024).toFixed(2)} KB)`;
            fileInfo.classList.add('show');

            // Parse CSV and detect columns
            parseAndDetectColumns(file);
        }

        // Parse CSV and detect columns
        function parseAndDetectColumns(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const rows = text.split('\n').filter(row => row.trim());

                if (rows.length === 0) {
                    alert('CSV file is empty');
                    return;
                }

                // Parse header and first few rows
                // Remove BOM if present and clean headers
                const headers = rows[0].split(',').map(h => h.trim().replace(/"/g, '').replace(/^\uFEFF/, ''));
                const dataRows = rows.slice(1, Math.min(100, rows.length)).map(row => {
                    return row.split(',').map(cell => cell.trim().replace(/"/g, ''));
                });

                csvData = { headers, rows: dataRows, fullText: text };

                // Detect columns
                detectColumns(headers, dataRows);
            };
            reader.readAsText(file);
        }

        // Detect column types
        function detectColumns(headers, dataRows) {
            detectedColumns = {
                zip: null,
                fips: null,
                ecode: null,
                rcode: null,
                dcode: null,
                numeric: [],
                all: headers,
                isHierarchical: false,  // NEW: track if this is a hierarchical CSV from Roll-Up tab
                hierarchicalFields: {}  // NEW: map base field name to level-specific columns
            };

            // Detect if this is a hierarchical CSV (from Roll-Up tab)
            // These have columns like "Drives (ZIP)", "Drives (County)", etc.
            const levelSuffixes = ['(ZIP)', '(County)', '(Chapter)', '(Region)', '(Division)'];
            const hierarchicalColumns = headers.filter(h =>
                levelSuffixes.some(suffix => h.includes(suffix))
            );

            if (hierarchicalColumns.length > 0) {
                console.log('‚úì Detected hierarchical CSV with level-specific columns');
                detectedColumns.isHierarchical = true;

                // Extract base field names and map to level-specific columns
                hierarchicalColumns.forEach((header, index) => {
                    // Extract base field name (before the level suffix)
                    const match = header.match(/^(.+?)\s*\((ZIP|County|Chapter|Region|Division)\)$/);
                    if (match) {
                        const baseField = match[1];  // e.g., "Row Count", "Drives"
                        const level = match[2].toLowerCase();  // e.g., "zip", "county"

                        if (!detectedColumns.hierarchicalFields[baseField]) {
                            detectedColumns.hierarchicalFields[baseField] = {};
                        }
                        detectedColumns.hierarchicalFields[baseField][level] = {
                            name: header,
                            index: headers.indexOf(header)
                        };
                    }
                });

                console.log('Hierarchical fields detected:', Object.keys(detectedColumns.hierarchicalFields));
            }

            // Flexible column name matching
            const zipPatterns = ['zip', 'zipcode', 'zip_code', 'postal', 'postalcode'];
            const fipsPatterns = ['fips', 'county_fips', 'countyfips', 'geoid', 'county_code'];
            const ecodePatterns = ['ecode', 'chapter', 'chapter_code', 'chaptercode'];
            const rcodePatterns = ['rcode', 'region', 'region_code', 'regioncode'];
            const dcodePatterns = ['dcode', 'division', 'division_code', 'divisioncode'];

            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase();

                // Skip hierarchical columns when looking for ID columns
                const isHierarchicalColumn = levelSuffixes.some(suffix => header.includes(suffix));

                // Check for geographic columns (only if not a hierarchical data column)
                if (!isHierarchicalColumn) {
                    if (zipPatterns.some(p => headerLower.includes(p))) {
                        detectedColumns.zip = { name: header, index };
                    } else if (fipsPatterns.some(p => headerLower.includes(p))) {
                        detectedColumns.fips = { name: header, index };
                    } else if (ecodePatterns.some(p => headerLower.includes(p))) {
                        detectedColumns.ecode = { name: header, index };
                    } else if (rcodePatterns.some(p => headerLower.includes(p))) {
                        detectedColumns.rcode = { name: header, index };
                    } else if (dcodePatterns.some(p => headerLower.includes(p))) {
                        detectedColumns.dcode = { name: header, index };
                    }
                }

                // Check if column is numeric (sample first 10 rows)
                // Skip if this column was already identified as a geographic column
                const isGeoColumn = detectedColumns.zip?.index === index ||
                                   detectedColumns.fips?.index === index ||
                                   detectedColumns.ecode?.index === index ||
                                   detectedColumns.rcode?.index === index ||
                                   detectedColumns.dcode?.index === index;

                if (!isGeoColumn && !detectedColumns.isHierarchical) {
                    // Only detect numeric columns for non-hierarchical CSVs
                    const sample = dataRows.slice(0, 10).map(row => row[index]);
                    // Check if values are numeric (allow empty strings)
                    const numericValues = sample.filter(val => val !== '');
                    const isNumeric = numericValues.length > 0 &&
                                     numericValues.every(val => !isNaN(parseFloat(val)));

                    if (isNumeric) {
                        detectedColumns.numeric.push({ name: header, index });
                    }
                }
            });

            // Auto-detect granularity
            let detectedGranularity = 'county'; // default
            if (detectedColumns.zip) {
                detectedGranularity = 'zip';
            }

            // Update UI
            displayColumnDetection(detectedGranularity);
            processBtn.disabled = false;
        }

        // Display column detection results
        function displayColumnDetection(detectedGranularity) {
            // Show the section
            document.getElementById('columnDetectionSection').style.display = 'block';

            // Set detected level
            document.getElementById('detectedLevelText').textContent =
                detectedGranularity === 'zip' ? 'ZIP Code Level (found ZIP column)' : 'County Level (found FIPS/County column)';

            // Set radio button
            if (detectedGranularity === 'zip') {
                document.getElementById('granularityZip').checked = true;
            } else {
                document.getElementById('granularityCounty').checked = true;
            }
            aggregationConfig.granularity = detectedGranularity;

            // Display aggregation field options
            const fieldsContainer = document.getElementById('aggregationFields');
            fieldsContainer.innerHTML = '';

            // For hierarchical CSVs, show base field names
            if (detectedColumns.isHierarchical) {
                // Add aggregation fields based on hierarchical base fields
                const allowedSumFields = ['Drives', 'RBC Product Projection', 'RBC Products Collected'];

                Object.keys(detectedColumns.hierarchicalFields).forEach(baseField => {
                    if (baseField === 'Row Count') {
                        // COUNT type
                        const option = createAggregationFieldOption(baseField, baseField, 'COUNT', true);
                        fieldsContainer.appendChild(option);
                    } else if (allowedSumFields.includes(baseField)) {
                        // SUM type
                        const option = createAggregationFieldOption(baseField, baseField, 'SUM', true);
                        fieldsContainer.appendChild(option);
                    }
                });
            } else {
                // Original logic for non-hierarchical CSVs
                // Add COUNT option
                const countOption = createAggregationFieldOption('Row Count', 'count', 'COUNT');
                fieldsContainer.appendChild(countOption);

                // Add numeric columns (only Drives and RBC fields)
                const allowedSumFields = ['Drives', 'RBC Product Projection', 'RBC Products Collected'];
                detectedColumns.numeric.forEach(col => {
                    if (allowedSumFields.includes(col.name)) {
                        const option = createAggregationFieldOption(col.name, col.name, 'SUM', true);
                        fieldsContainer.appendChild(option);
                    }
                });
            }

            // Display column mapping
            const mappingContainer = document.getElementById('columnMapping');
            let mappingHtml = '<div style="display: grid; grid-template-columns: 150px 1fr; gap: 10px; font-size: 0.9em;">';

            if (detectedColumns.zip) {
                mappingHtml += `<strong>ZIP Code:</strong><span>${detectedColumns.zip.name}</span>`;
            }
            if (detectedColumns.fips) {
                mappingHtml += `<strong>County FIPS:</strong><span>${detectedColumns.fips.name}</span>`;
            }
            if (detectedColumns.ecode) {
                mappingHtml += `<strong>Chapter (ECODE):</strong><span>${detectedColumns.ecode.name}</span>`;
            }
            if (detectedColumns.rcode) {
                mappingHtml += `<strong>Region (RCODE):</strong><span>${detectedColumns.rcode.name}</span>`;
            }
            if (detectedColumns.dcode) {
                mappingHtml += `<strong>Division (DCODE):</strong><span>${detectedColumns.dcode.name}</span>`;
            }

            mappingHtml += '</div>';
            mappingContainer.innerHTML = mappingHtml;

            // Update option cards
            updateOptionCards();

            // Show and update aggregation summary
            updateAggregationSummary();
        }

        // Update aggregation summary
        function updateAggregationSummary() {
            if (!aggregationConfig.fields || aggregationConfig.fields.length === 0) {
                document.getElementById('aggregationSummary').style.display = 'none';
                return;
            }

            document.getElementById('aggregationSummary').style.display = 'block';

            let summaryHtml = '<ul style="margin: 0; padding-left: 20px;">';
            summaryHtml += `<li><strong>Input Level:</strong> ${aggregationConfig.granularity === 'zip' ? 'ZIP Code' : 'County'}</li>`;
            summaryHtml += '<li><strong>Metrics to aggregate:</strong><ul style="margin-top: 5px;">';

            aggregationConfig.fields.forEach(field => {
                summaryHtml += `<li>${field.label}: <code>${field.type}</code></li>`;
            });

            summaryHtml += '</ul></li>';
            summaryHtml += '<li><strong>Hierarchical roll-ups:</strong> ';

            if (aggregationConfig.granularity === 'zip') {
                summaryHtml += 'ZIP ‚Üí County ‚Üí Chapter ‚Üí Region ‚Üí Division';
            } else {
                summaryHtml += 'County ‚Üí Chapter ‚Üí Region ‚Üí Division';
            }

            summaryHtml += '</li>';
            summaryHtml += '</ul>';

            document.getElementById('summaryContent').innerHTML = summaryHtml;
        }

        // Create aggregation field option
        function createAggregationFieldOption(label, fieldName, defaultType, checked = true) {
            const div = document.createElement('div');
            div.style.cssText = 'display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = checked;
            checkbox.id = `agg_${fieldName}`;
            checkbox.style.cssText = 'width: 18px; height: 18px; accent-color: #DC143C;';

            const labelEl = document.createElement('label');
            labelEl.textContent = label;
            labelEl.style.cssText = 'flex: 1; font-weight: 500; cursor: pointer;';
            labelEl.htmlFor = `agg_${fieldName}`;

            const select = document.createElement('select');
            select.style.cssText = 'padding: 6px 10px; border: 1px solid #e0e0e0; border-radius: 3px; background: white;';
            select.innerHTML = `
                <option value="COUNT" ${defaultType === 'COUNT' ? 'selected' : ''}>COUNT</option>
                <option value="SUM" ${defaultType === 'SUM' ? 'selected' : ''}>SUM</option>
            `;

            // Update config on change
            const updateConfig = () => {
                if (checkbox.checked) {
                    aggregationConfig.fields = aggregationConfig.fields.filter(f => f.field !== fieldName);
                    aggregationConfig.fields.push({
                        field: fieldName,
                        type: select.value,
                        label: label
                    });
                } else {
                    aggregationConfig.fields = aggregationConfig.fields.filter(f => f.field !== fieldName);
                }
                updateAggregationSummary();
            };

            checkbox.addEventListener('change', updateConfig);
            select.addEventListener('change', updateConfig);

            // Initial config
            updateConfig();

            div.appendChild(checkbox);
            div.appendChild(labelEl);
            div.appendChild(select);

            return div;
        }

        // Update granularity on radio change
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('input[name="granularity"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    aggregationConfig.granularity = e.target.value;
                    updateAggregationSummary();
                });
            });
        });

        // Option card interactions
        document.querySelectorAll('.option-card').forEach(card => {
            const checkbox = card.querySelector('input[type="checkbox"]');
            
            card.addEventListener('click', (e) => {
                if (e.target !== checkbox) {
                    checkbox.checked = !checkbox.checked;
                }
                updateCardState(card, checkbox.checked);
            });

            checkbox.addEventListener('change', () => {
                updateCardState(card, checkbox.checked);
            });
        });

        function updateCardState(card, checked) {
            if (checked) {
                card.classList.add('selected');
            } else {
                card.classList.remove('selected');
            }
        }

        function updateOptionCards() {
            document.querySelectorAll('.option-card').forEach(card => {
                updateCardState(card, card.querySelector('input[type="checkbox"]').checked);
            });
        }

        // Process button
        processBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            const selectedLevels = [];
            if (document.getElementById('optZip').checked) selectedLevels.push('zip');
            if (document.getElementById('optCounty').checked) selectedLevels.push('county');
            if (document.getElementById('optChapter').checked) selectedLevels.push('chapter');
            if (document.getElementById('optRegion').checked) selectedLevels.push('region');
            if (document.getElementById('optDivision').checked) selectedLevels.push('division');

            if (selectedLevels.length === 0) {
                alert('Please select at least one output level');
                return;
            }

            // Validate aggregation config
            if (!aggregationConfig.fields || aggregationConfig.fields.length === 0) {
                alert('Please select at least one field to aggregate');
                return;
            }

            processBtn.disabled = true;
            progress.classList.add('show');
            results.classList.remove('show');
            resultGrid.innerHTML = '';

            // Log configuration for backend processing
            console.log('Aggregation Configuration:', {
                granularity: aggregationConfig.granularity,
                fields: aggregationConfig.fields,
                detectedColumns: detectedColumns,
                outputLevels: selectedLevels
            });

            // Upload file first, then process with aggregation
            try {
                await uploadAndProcess(selectedLevels);
            } catch (error) {
                alert('Error: ' + error.message);
                processBtn.disabled = false;
            }
        });

        // CLIENT-SIDE PROCESSING
        async function uploadAndProcess(levels) {
            try {
                // Step 1: Parse full CSV
                updateProgress(5, 'Parsing CSV file...');
                const fullCSV = await parseFullCSV(selectedFile);

                // Step 2: Load boundary files for selected levels
                updateProgress(15, 'Loading geographic boundaries...');
                await loadBoundaries(levels);

                // Step 3: Process differently for hierarchical vs non-hierarchical CSVs
                if (detectedColumns.isHierarchical) {
                    // NEW PATH: Hierarchical CSV - process each level separately
                    console.log('‚úì Processing hierarchical CSV - creating separate aggregations per level');
                    updateProgress(30, 'Processing hierarchical data...');

                    for (const level of levels) {
                        updateProgress(30 + (levels.indexOf(level) / levels.length) * 40,
                            `Creating ${level}-level GeoJSON...`);

                        // Create level-specific aggregation
                        const levelAggregated = aggregateHierarchicalData(fullCSV, level);
                        await createGeoJSONFiles(levelAggregated, [level]);
                    }
                } else {
                    // ORIGINAL PATH: Non-hierarchical CSV
                    const isPreAggregated = detectIfPreAggregated(fullCSV);
                    let aggregated;

                    if (isPreAggregated) {
                        updateProgress(30, 'Detected pre-aggregated CSV, using data directly...');
                        aggregated = convertPreAggregatedToFormat(fullCSV);
                        console.log('‚úì Using pre-aggregated data from CSV Roll-Up tab');
                    } else {
                        updateProgress(30, `Aggregating row-level data at ${aggregationConfig.granularity} level...`);
                        aggregated = aggregateData(fullCSV);
                        console.log('‚úì Aggregated row-level data');
                    }

                    // Step 4: Perform joins and create GeoJSON
                    updateProgress(50, 'Creating GeoJSON files...');
                    await createGeoJSONFiles(aggregated, levels);
                }

                // Step 5: Show preview map
                updateProgress(90, 'Generating preview map...');
                showPreviewMap(levels[0]);

                // Step 6: Display download links
                updateProgress(100, 'Complete! All files generated successfully.');
                displayDownloadLinks(levels);

                processBtn.disabled = false;
                processBtn.textContent = '‚ú® Process Complete - Upload Another File';
            } catch (error) {
                throw error;
            }
        }

        // Detect if CSV is pre-aggregated (from Roll-Up tab) or row-level
        function detectIfPreAggregated(csvData) {
            const { headers } = csvData;

            // Pre-aggregated CSVs have columns like "Row Count", "Drives", "RBC Product Projection"
            const aggregatedFieldNames = ['Row Count', 'Drives', 'RBC Product Projection', 'RBC Products Collected'];
            const hasAggregatedFields = aggregatedFieldNames.some(field => headers.includes(field));

            // Pre-aggregated CSVs have a geographic key column but not many other columns
            const hasMinimalColumns = headers.length <= 6; // Key + few metrics

            return hasAggregatedFields && hasMinimalColumns;
        }

        // Convert pre-aggregated CSV to the format expected by createGeoJSONFiles
        function convertPreAggregatedToFormat(csvData) {
            const { headers, dataRows } = csvData;
            const result = {};

            // Find the key column (ZIP, County_FIPS, ECODE, RCODE, or DCODE)
            const keyColumnIndex = headers.findIndex(h =>
                ['ZIP', 'County_FIPS', 'ECODE', 'RCODE', 'DCODE'].includes(h)
            );

            if (keyColumnIndex === -1) {
                throw new Error('Could not find geographic key column in pre-aggregated CSV');
            }

            dataRows.forEach(row => {
                const key = row[keyColumnIndex];
                if (!key) return;

                result[key] = {
                    key: key,
                    aggregates: {}
                };

                // Add all metric columns as aggregates
                headers.forEach((header, index) => {
                    if (index !== keyColumnIndex) {
                        const value = parseFloat(row[index]) || 0;
                        result[key].aggregates[header] = value;
                    }
                });
            });

            console.log(`‚úì Converted ${Object.keys(result).length} pre-aggregated records`);
            return result;
        }

        // Parse entire CSV file
        // Proper CSV line parser that handles quoted fields with commas
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;

            for (let i = 0; i < line.length; i++) {
                const char = line[i];

                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            return result;
        }

        async function parseFullCSV(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const text = e.target.result;
                    const rows = text.split('\n').filter(row => row.trim());

                    if (rows.length === 0) {
                        reject(new Error('CSV file is empty'));
                        return;
                    }

                    const headers = parseCSVLine(rows[0]).map(h => h.replace(/^\uFEFF/, ''));
                    const dataRows = rows.slice(1).map(row => parseCSVLine(row));

                    resolve({ headers, dataRows });
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        // Aggregate hierarchical CSV data for a specific level
        function aggregateHierarchicalData(csvData, targetLevel) {
            const { headers, dataRows } = csvData;

            // Determine the ID column for this level
            let levelIdColumn;
            if (targetLevel === 'zip') {
                levelIdColumn = detectedColumns.zip;
            } else if (targetLevel === 'county') {
                // For county level, we still group by ZIP but extract county-level data
                levelIdColumn = detectedColumns.zip;
            } else if (targetLevel === 'chapter') {
                levelIdColumn = detectedColumns.ecode;
            } else if (targetLevel === 'region') {
                levelIdColumn = detectedColumns.rcode;
            } else if (targetLevel === 'division') {
                levelIdColumn = detectedColumns.dcode;
            }

            if (!levelIdColumn) {
                throw new Error(`No ID column found for ${targetLevel} level`);
            }

            console.log(`Grouping by ${levelIdColumn.name} (column index ${levelIdColumn.index}) for ${targetLevel} level`);

            const grouped = {};

            // Group rows by the level's ID column
            dataRows.forEach(row => {
                const key = row[levelIdColumn.index];
                if (!key) return;

                // DEBUG: Log first key to verify
                if (Object.keys(grouped).length === 0) {
                    console.log(`First ${targetLevel} key found: "${key}" from column ${levelIdColumn.index}`);
                }

                if (!grouped[key]) {
                    grouped[key] = {
                        key: key,
                        aggregates: {}
                    };
                }

                // Extract values from the hierarchical columns for this level
                // Since all rows with the same ID have the same values for that level,
                // we can just take the value from this row
                aggregationConfig.fields.forEach(field => {
                    const hierarchicalFieldInfo = detectedColumns.hierarchicalFields[field.field];
                    if (hierarchicalFieldInfo && hierarchicalFieldInfo[targetLevel]) {
                        const colIndex = hierarchicalFieldInfo[targetLevel].index;
                        const val = parseFloat(row[colIndex]) || 0;
                        grouped[key].aggregates[field.field] = val;
                    } else {
                        console.warn(`No ${targetLevel} column found for field ${field.field}`);
                        grouped[key].aggregates[field.field] = 0;
                    }
                });
            });

            console.log(`‚úì Created ${Object.keys(grouped).length} ${targetLevel}-level aggregations`);
            return grouped;
        }

        // Aggregate CSV data
        function aggregateData(csvData) {
            const { headers, dataRows } = csvData;
            const groupKey = aggregationConfig.granularity === 'zip' ? 'zip' : 'fips';
            const keyColumn = detectedColumns[groupKey];

            if (!keyColumn) {
                throw new Error(`No ${groupKey.toUpperCase()} column found`);
            }

            const grouped = {};

            // For hierarchical CSVs, determine which level to extract data from
            // based on the selected output levels
            let targetLevel = null;
            if (detectedColumns.isHierarchical) {
                // Determine target level based on output levels selected
                const outputLevels = aggregationConfig.outputLevels || [];
                if (outputLevels.includes('division')) targetLevel = 'division';
                else if (outputLevels.includes('region')) targetLevel = 'region';
                else if (outputLevels.includes('chapter')) targetLevel = 'chapter';
                else if (outputLevels.includes('county')) targetLevel = 'county';
                else if (outputLevels.includes('zip')) targetLevel = 'zip';

                console.log(`Hierarchical CSV detected - extracting ${targetLevel} level data`);
            }

            // Group rows by key
            dataRows.forEach(row => {
                const key = row[keyColumn.index];
                if (!key) return;

                if (!grouped[key]) {
                    grouped[key] = {
                        key: key,
                        rows: [],
                        aggregates: {}
                    };
                }
                grouped[key].rows.push(row);
            });

            // Calculate aggregates
            Object.values(grouped).forEach(group => {
                aggregationConfig.fields.forEach(field => {
                    if (detectedColumns.isHierarchical && targetLevel) {
                        // For hierarchical CSVs, extract the value directly from the appropriate column
                        const hierarchicalFieldInfo = detectedColumns.hierarchicalFields[field.field];
                        if (hierarchicalFieldInfo && hierarchicalFieldInfo[targetLevel]) {
                            const colIndex = hierarchicalFieldInfo[targetLevel].index;
                            // For hierarchical CSVs, take the value from the first row (all rows have same value for that level)
                            const val = parseFloat(group.rows[0][colIndex]) || 0;
                            group.aggregates[field.field] = val;
                        } else {
                            console.warn(`No ${targetLevel} column found for field ${field.field}`);
                            group.aggregates[field.field] = 0;
                        }
                    } else {
                        // Original aggregation logic for non-hierarchical CSVs
                        if (field.type === 'COUNT') {
                            group.aggregates[field.field] = group.rows.length;
                        } else if (field.type === 'SUM') {
                            const colIndex = headers.indexOf(field.field);
                            group.aggregates[field.field] = group.rows.reduce((sum, row) => {
                                const val = parseFloat(row[colIndex]) || 0;
                                return sum + val;
                            }, 0);
                        }
                    }
                });
            });

            return grouped;
        }

        // Load geographic boundary files
        async function loadBoundaries(levels) {
            const promises = [];

            // Determine base URL for boundary files
            const isLocalhost = window.location.hostname === 'localhost' ||
                               window.location.hostname === '127.0.0.1' ||
                               window.location.hostname === '';

            console.log(`Loading boundaries (hostname: ${window.location.hostname}, isLocalhost: ${isLocalhost})`);

            for (const level of levels) {
                if (!geoBoundaries[level]) {
                    // Use official ArcGIS Red Cross geography service for most levels
                    // ZIP boundaries come from GitHub (Census ZCTA data)
                    let url;

                    const arcgisLayers = {
                        'division': 1,
                        'region': 2,
                        'chapter': 4,
                        'county': 5
                    };

                    if (arcgisLayers[level]) {
                        // Load from ArcGIS Feature Service (always up-to-date with official Red Cross geography)
                        const layerId = arcgisLayers[level];
                        url = `https://services.arcgis.com/pGfbNJoYypmNq86F/ArcGIS/rest/services/Master_ARC_Geography_2022/FeatureServer/${layerId}/query?where=1=1&outFields=*&f=geojson`;
                    } else if (level === 'zip') {
                        // ZIP boundaries from GitHub (Census ZCTA data in Git LFS)
                        url = `https://media.githubusercontent.com/media/franzenjb/GeoJSON-Creation-Tool/geodata-files/geographic-data/${level}_boundaries.geojson`;
                    } else {
                        // Fallback to GitHub
                        url = `https://raw.githubusercontent.com/franzenjb/GeoJSON-Creation-Tool/geodata-files/geographic-data/${level}_boundaries.geojson`;
                    }

                    console.log(`Fetching ${level} from: ${url}`);

                    promises.push(
                        fetch(url)
                            .then(r => {
                                if (!r.ok) {
                                    throw new Error(`Failed to load ${level} boundaries: ${r.status} from ${url}`);
                                }
                                return r.json();
                            })
                            .then(data => {
                                console.log(`‚úì Loaded ${level} boundaries (${data.features?.length || 0} features)`);
                                geoBoundaries[level] = data;
                            })
                            .catch(err => {
                                console.error(`‚úó Error loading ${level} boundaries from ${url}:`, err);
                                throw err;
                            })
                    );
                }
            }

            await Promise.all(promises);
        }

        // Create GeoJSON files with joins
        async function createGeoJSONFiles(aggregated, levels) {
            for (const level of levels) {
                const boundary = geoBoundaries[level];
                if (!boundary) continue;

                // Clone boundary and add aggregated data
                const output = JSON.parse(JSON.stringify(boundary));

                // Proper join logic for each level
                let joinedCount = 0;

                // DEBUG: Log what keys we have in aggregated data
                const aggregatedKeys = Object.keys(aggregated);
                console.log(`Aggregated data has ${aggregatedKeys.length} keys for ${level}. Sample:`, aggregatedKeys.slice(0, 5));

                output.features.forEach(feature => {
                    const props = feature.properties;
                    let matchKey = null;

                    // Determine the correct property key for this level
                    if (level === 'zip') {
                        matchKey = props.ZIP || props.ZCTA5CE20;
                    } else if (level === 'county') {
                        matchKey = props.County_FIPS || props.GEOID;
                    } else if (level === 'chapter') {
                        matchKey = props.ECODE;
                    } else if (level === 'region') {
                        matchKey = props.RCODE;
                    } else if (level === 'division') {
                        matchKey = props.DCODE;
                    }

                    // Match and add aggregated data
                    if (matchKey && aggregated[matchKey]) {
                        Object.assign(props, aggregated[matchKey].aggregates);
                        joinedCount++;
                    } else if (matchKey) {
                        console.log(`No match found for ${level} key: ${matchKey}`);
                    }
                });

                console.log(`‚úì Joined ${joinedCount} features at ${level} level (out of ${output.features.length})`);
                generatedGeoJSON[level] = output;
            }
        }

        // Show preview map
        function showPreviewMap(initialLevel) {
            document.getElementById('previewSection').style.display = 'block';
            document.getElementById('previewSection').classList.add('show');

            if (!previewMap) {
                previewMap = L.map('map').setView([39.8283, -98.5795], 4);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '¬© OpenStreetMap contributors'
                }).addTo(previewMap);

                // Add level selector handler
                document.getElementById('previewLevel').addEventListener('change', (e) => {
                    updateMapLayer(e.target.value);
                });
            }

            updateMapLayer(initialLevel);
        }

        // Update map layer
        function updateMapLayer(level) {
            if (currentLayer) {
                previewMap.removeLayer(currentLayer);
            }

            const geoJSON = generatedGeoJSON[level];
            if (!geoJSON) return;

            currentLayer = L.geoJSON(geoJSON, {
                style: feature => ({
                    fillColor: getColor(feature.properties),
                    weight: 1,
                    opacity: 1,
                    color: 'white',
                    fillOpacity: 0.7
                }),
                onEachFeature: (feature, layer) => {
                    layer.bindPopup(createPopup(feature.properties));
                }
            }).addTo(previewMap);

            previewMap.fitBounds(currentLayer.getBounds());
        }

        // Get color for choropleth
        function getColor(properties) {
            const firstMetric = aggregationConfig.fields[0];
            if (!firstMetric) return '#cccccc';

            const value = properties[firstMetric.field] || 0;
            return value > 100 ? '#800026' :
                   value > 50  ? '#BD0026' :
                   value > 20  ? '#E31A1C' :
                   value > 10  ? '#FC4E2A' :
                   value > 5   ? '#FD8D3C' :
                   value > 2   ? '#FEB24C' :
                   value > 0   ? '#FED976' :
                                 '#FFEDA0';
        }

        // Create popup content
        function createPopup(properties) {
            let html = '<div style="font-size: 0.9em;">';
            html += `<strong>${properties.NAME || properties.ZIP || 'Unknown'}</strong><br>`;
            aggregationConfig.fields.forEach(field => {
                html += `${field.label}: ${properties[field.field] || 0}<br>`;
            });
            html += '</div>';
            return html;
        }

        // Display download links
        function displayDownloadLinks(levels) {
            resultGrid.innerHTML = '';

            levels.forEach(level => {
                if (generatedGeoJSON[level]) {
                    const jsonString = JSON.stringify(generatedGeoJSON[level]);
                    const size = new Blob([jsonString]).size;
                    createResultCard(level, `${level}_output.geojson`, size, null, jsonString);
                }
            });

            results.classList.add('show');
        }

        function updateProgress(percent, message) {
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';
            status.textContent = message;
        }

        function createResultCard(level, filename, sizeBytes, filepath, jsonString) {
            const levelInfo = {
                zip: { icon: 'üì¶', name: 'ZIP Codes' },
                county: { icon: 'üèõÔ∏è', name: 'Counties' },
                chapter: { icon: 'üìö', name: 'Chapters' },
                region: { icon: 'üåç', name: 'Regions' },
                division: { icon: 'üåé', name: 'Divisions' }
            };

            const info = levelInfo[level] || { icon: 'üìÑ', name: level };
            const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);

            const card = document.createElement('div');
            card.className = 'result-card';
            card.innerHTML = `
                <div class="icon">${info.icon}</div>
                <div class="filename">${filename}</div>
                <div class="size">${sizeMB} MB</div>
                <button class="download-btn">Download</button>
            `;

            // Add click handler for client-side download
            const downloadBtn = card.querySelector('.download-btn');
            downloadBtn.addEventListener('click', () => {
                downloadGeoJSON(jsonString, filename);
            });

            resultGrid.appendChild(card);
            results.classList.add('show');
        }

        // Client-side download
        function downloadGeoJSON(jsonString, filename) {
            const blob = new Blob([jsonString], { type: 'application/geo+json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function downloadFile(filepath) {
            try {
                const response = await fetch(`/api/download/${filepath}`);
                if (!response.ok) {
                    throw new Error('Download failed');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                alert('Error downloading file: ' + error.message);
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Tab functionality
        function showTab(tabName) {
            // Hide all tabs
            document.getElementById('createTab').style.display = 'none';
            document.getElementById('lookupTab').style.display = 'none';
            document.getElementById('rollupTab').style.display = 'none';
            document.getElementById('orglerTab').style.display = 'none';
            document.getElementById('popupTab').style.display = 'none';
            document.getElementById('geocoderTab').style.display = 'none';

            // Remove active class from all buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.style.borderBottomColor = 'transparent';
                btn.style.color = '#666';
            });

            // Show selected tab
            if (tabName === 'lookup') {
                document.getElementById('lookupTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[0].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[0].style.color = '#DC143C';
            } else if (tabName === 'rollup') {
                document.getElementById('rollupTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[1].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[1].style.color = '#DC143C';
            } else if (tabName === 'create') {
                document.getElementById('createTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[2].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[2].style.color = '#DC143C';
            } else if (tabName === 'orgler') {
                document.getElementById('orglerTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[3].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[3].style.color = '#DC143C';
            } else if (tabName === 'popup') {
                document.getElementById('popupTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[4].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[4].style.color = '#DC143C';
            } else if (tabName === 'geocoder') {
                document.getElementById('geocoderTab').style.display = 'block';
                document.querySelectorAll('.tab-btn')[5].style.borderBottomColor = '#DC143C';
                document.querySelectorAll('.tab-btn')[5].style.color = '#DC143C';
            }
        }

        // Accordion functionality
        function toggleAccordion(accordionId) {
            const content = document.getElementById(accordionId);
            const header = content.previousElementSibling;

            if (content.classList.contains('active')) {
                // Collapse
                content.style.maxHeight = null;
                content.classList.remove('active');
                header.classList.remove('active');
            } else {
                // Expand
                content.classList.add('active');
                header.classList.add('active');
                content.style.maxHeight = content.scrollHeight + 'px';
            }
        }

        // ==================== CSV ROLL-UP TAB FUNCTIONALITY ====================

        // CSV Roll-Up state
        let rollupCsvData = null;
        let rollupDetectedColumns = null;
        let rollupAggregationConfig = {
            granularity: null,  // 'zip' or 'county'
            fields: [],
            outputLevels: []
        };
        let rollupGeneratedCSVs = {};

        // Get rollup tab elements
        const rollupUploadArea = document.getElementById('rollupUploadArea');
        const rollupFileInput = document.getElementById('rollupFileInput');
        const rollupFileInfo = document.getElementById('rollupFileInfo');
        const rollupFileName = document.getElementById('rollupFileName');
        const rollupFileSize = document.getElementById('rollupFileSize');
        const rollupColumnDetectionSection = document.getElementById('rollupColumnDetectionSection');
        const rollupDetectedLevelText = document.getElementById('rollupDetectedLevelText');
        const rollupAggregationFields = document.getElementById('rollupAggregationFields');
        const rollupOutputLevels = document.getElementById('rollupOutputLevels');
        const rollupProcessBtn = document.getElementById('rollupProcessBtn');
        const rollupProgressSection = document.getElementById('rollupProgressSection');
        const rollupProgressFill = document.getElementById('rollupProgressFill');
        const rollupStatus = document.getElementById('rollupStatus');
        const rollupResultSection = document.getElementById('rollupResultSection');
        const rollupResultGrid = document.getElementById('rollupResultGrid');

        // Upload handlers for rollup tab
        rollupUploadArea.addEventListener('click', () => rollupFileInput.click());
        rollupFileInput.addEventListener('change', (e) => handleRollupFile(e.target.files[0]));

        rollupUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            rollupUploadArea.style.borderColor = '#ff4060';
            rollupUploadArea.style.background = '#fff5f7';
        });

        rollupUploadArea.addEventListener('dragleave', () => {
            rollupUploadArea.style.borderColor = '#DC143C';
            rollupUploadArea.style.background = '#fafafa';
        });

        rollupUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            rollupUploadArea.style.borderColor = '#DC143C';
            rollupUploadArea.style.background = '#fafafa';
            handleRollupFile(e.dataTransfer.files[0]);
        });

        function handleRollupFile(file) {
            if (!file || !file.name.endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            rollupFileName.textContent = file.name;
            rollupFileSize.textContent = `(${(file.size / 1024).toFixed(2)} KB)`;
            rollupFileInfo.style.display = 'block';

            // Parse CSV and detect columns
            parseRollupCSV(file);
        }

        function parseRollupCSV(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const rows = text.split('\n').filter(row => row.trim());

                if (rows.length === 0) {
                    alert('CSV file is empty');
                    return;
                }

                // Parse header and all rows
                const headers = rows[0].split(',').map(h => h.trim().replace(/"/g, '').replace(/^\uFEFF/, ''));
                const dataRows = rows.slice(1).map(row => {
                    return row.split(',').map(cell => cell.trim().replace(/"/g, ''));
                });

                rollupCsvData = { headers, dataRows };

                // Detect columns
                detectRollupColumns(headers, dataRows);
            };
            reader.readAsText(file);
        }

        function detectRollupColumns(headers, dataRows) {
            rollupDetectedColumns = {
                zip: null,
                fips: null,
                ecode: null,
                rcode: null,
                dcode: null,
                numeric: [],
                all: headers
            };

            // Detect geographic columns
            const zipPatterns = ['zip', 'zipcode', 'zip_code', 'postal', 'postalcode'];
            const fipsPatterns = ['fips', 'county_fips', 'countyfips', 'geoid'];
            const ecodePatterns = ['ecode', 'chapter', 'chaptercode'];
            const rcodePatterns = ['rcode', 'region', 'regioncode'];
            const dcodePatterns = ['dcode', 'division', 'divisioncode'];

            headers.forEach((header, index) => {
                const headerLower = header.toLowerCase();

                if (zipPatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.zip = { name: header, index };
                } else if (fipsPatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.fips = { name: header, index };
                } else if (ecodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.ecode = { name: header, index };
                } else if (rcodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.rcode = { name: header, index };
                } else if (dcodePatterns.some(p => headerLower.includes(p))) {
                    rollupDetectedColumns.dcode = { name: header, index };
                }

                // Check if column is numeric
                const isGeoColumn =
                    rollupDetectedColumns.zip?.index === index ||
                    rollupDetectedColumns.fips?.index === index ||
                    rollupDetectedColumns.ecode?.index === index ||
                    rollupDetectedColumns.rcode?.index === index ||
                    rollupDetectedColumns.dcode?.index === index;

                if (!isGeoColumn) {
                    const sample = dataRows.slice(0, 10).map(row => row[index]);
                    const numericValues = sample.filter(val => val !== '');
                    const isNumeric = numericValues.length > 0 &&
                                     numericValues.every(val => !isNaN(parseFloat(val)));
                    if (isNumeric) {
                        rollupDetectedColumns.numeric.push({ name: header, index });
                    }
                }
            });

            // Determine granularity
            const detectedGranularity = rollupDetectedColumns.zip ? 'zip' :
                                       rollupDetectedColumns.fips ? 'county' : null;

            if (!detectedGranularity) {
                alert('Could not detect ZIP or County FIPS column. Please ensure your CSV has a column with ZIP codes or County FIPS codes.');
                return;
            }

            rollupAggregationConfig.granularity = detectedGranularity;

            // Display column detection results
            displayRollupColumnDetection(detectedGranularity);
        }

        function displayRollupColumnDetection(detectedGranularity) {
            // Show the section
            rollupColumnDetectionSection.style.display = 'block';

            // Set detected level
            rollupDetectedLevelText.textContent =
                detectedGranularity === 'zip' ? 'ZIP Code Level (found ZIP column)' : 'County Level (found FIPS/County column)';

            // Display aggregation field options
            rollupAggregationFields.innerHTML = '';

            // Add COUNT option
            const countOption = createRollupFieldOption('Row Count', 'count', 'COUNT');
            rollupAggregationFields.appendChild(countOption);

            // Add numeric columns (only Drives and RBC fields)
            const allowedSumFields = ['Drives', 'RBC Product Projection', 'RBC Products Collected'];
            rollupDetectedColumns.numeric.forEach(col => {
                if (allowedSumFields.includes(col.name)) {
                    const option = createRollupFieldOption(col.name, col.name, 'SUM', true);
                    rollupAggregationFields.appendChild(option);
                }
            });

            // Display output level options
            rollupOutputLevels.innerHTML = '';
            const levels = detectedGranularity === 'zip'
                ? ['zip', 'county', 'chapter', 'region', 'division']
                : ['county', 'chapter', 'region', 'division'];

            levels.forEach(level => {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `rollupLevel${level}`;
                checkbox.checked = true;
                checkbox.style.marginRight = '5px';

                const label = document.createElement('label');
                label.htmlFor = `rollupLevel${level}`;
                label.textContent = level.charAt(0).toUpperCase() + level.slice(1);
                label.style.cssText = 'display: flex; align-items: center; padding: 8px 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px; cursor: pointer;';

                const container = document.createElement('div');
                container.appendChild(checkbox);
                container.appendChild(label);

                rollupOutputLevels.appendChild(label);
                label.insertBefore(checkbox, label.firstChild);
            });
        }

        function createRollupFieldOption(label, fieldName, defaultType, checked = true) {
            const div = document.createElement('div');
            div.style.cssText = 'display: flex; align-items: center; gap: 12px; padding: 12px; background: white; border: 2px solid #e0e0e0; border-radius: 3px;';

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = checked;
            checkbox.id = `rollup_field_${fieldName}`;

            const labelEl = document.createElement('label');
            labelEl.htmlFor = `rollup_field_${fieldName}`;
            labelEl.textContent = label;
            labelEl.style.flex = '1';
            labelEl.style.cursor = 'pointer';

            const typeSpan = document.createElement('span');
            typeSpan.textContent = defaultType;
            typeSpan.style.cssText = 'padding: 4px 8px; background: #DC143C; color: white; border-radius: 3px; font-size: 0.85em; font-weight: 500;';

            div.appendChild(checkbox);
            div.appendChild(labelEl);
            div.appendChild(typeSpan);

            // Track in config
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    rollupAggregationConfig.fields.push({
                        field: fieldName,
                        label: label,
                        type: defaultType
                    });
                } else {
                    rollupAggregationConfig.fields = rollupAggregationConfig.fields.filter(f => f.field !== fieldName);
                }
            });

            // Initialize as checked
            if (checked) {
                rollupAggregationConfig.fields.push({
                    field: fieldName,
                    label: label,
                    type: defaultType
                });
            }

            return div;
        }

        // Process button handler
        rollupProcessBtn.addEventListener('click', async () => {
            if (!rollupCsvData || rollupAggregationConfig.fields.length === 0) {
                alert('Please select at least one metric to aggregate');
                return;
            }

            // Get selected output levels
            const selectedLevels = [];
            const levelCheckboxes = rollupOutputLevels.querySelectorAll('input[type="checkbox"]');
            levelCheckboxes.forEach(cb => {
                if (cb.checked) {
                    const level = cb.id.replace('rollupLevel', '');
                    selectedLevels.push(level);
                }
            });

            if (selectedLevels.length === 0) {
                alert('Please select at least one output level');
                return;
            }

            rollupAggregationConfig.outputLevels = selectedLevels;

            // Show progress
            rollupColumnDetectionSection.style.display = 'none';
            rollupProgressSection.style.display = 'block';
            rollupResultSection.style.display = 'none';

            try {
                await processRollupCSV();
            } catch (error) {
                console.error('Error processing CSV:', error);
                alert('Error processing CSV: ' + error.message);
                rollupProgressSection.style.display = 'none';
                rollupColumnDetectionSection.style.display = 'block';
            }
        });

        async function processRollupCSV() {
            updateRollupProgress(10, 'Parsing CSV data...');
            await sleep(100);

            // Step 1: Aggregate by base level (ZIP or County)
            updateRollupProgress(30, 'Aggregating by ' + rollupAggregationConfig.granularity + '...');
            const baseAggregated = aggregateRollupData(rollupCsvData);
            await sleep(100);

            // Step 2: Load boundary files to get hierarchy mapping
            updateRollupProgress(50, 'Loading geographic boundaries...');
            const boundaryData = await loadBoundaryForHierarchy(rollupAggregationConfig.granularity);
            await sleep(100);

            // Step 3: Perform hierarchical roll-ups
            updateRollupProgress(70, 'Performing hierarchical roll-ups...');
            rollupGeneratedCSVs = performHierarchicalRollup(baseAggregated, boundaryData);
            await sleep(100);

            // Step 4: Display download links
            updateRollupProgress(100, 'Complete! CSV files generated successfully.');
            await sleep(500);

            displayRollupDownloadLinks();
        }

        function aggregateRollupData(csvData) {
            const { headers, dataRows } = csvData;
            const groupKey = rollupAggregationConfig.granularity === 'zip' ? 'zip' : 'fips';
            const keyColumn = rollupDetectedColumns[groupKey];

            const grouped = {};

            dataRows.forEach(row => {
                const key = row[keyColumn.index];
                if (!key) return;

                if (!grouped[key]) {
                    grouped[key] = { key: key, rows: [], aggregates: {} };
                }
                grouped[key].rows.push(row);
            });

            // Calculate aggregates
            Object.values(grouped).forEach(group => {
                rollupAggregationConfig.fields.forEach(field => {
                    if (field.type === 'COUNT') {
                        group.aggregates[field.field] = group.rows.length;
                    } else if (field.type === 'SUM') {
                        const colIndex = headers.indexOf(field.field);
                        group.aggregates[field.field] = group.rows.reduce((sum, row) => {
                            const val = parseFloat(row[colIndex]) || 0;
                            return sum + val;
                        }, 0);
                    }
                });
            });

            return grouped;
        }

        async function loadBoundaryForHierarchy(granularity) {
            // Load comprehensive ZIP code hierarchy lookup (33K ZIPs, 99%+ US coverage)
            // This includes all Census ZIPs mapped to Red Cross Chapter/Region/Division hierarchy
            const url = './zip_to_redcross_comprehensive.csv';

            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to load ZIP hierarchy lookup: ${response.status}`);
            }

            const csvText = await response.text();
            const lines = csvText.split('\n').filter(line => line.trim());

            // Proper CSV parser that handles quoted fields with commas
            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            const headers = parseCSVLine(lines[0]);

            // Find column indices - New comprehensive CSV format:
            // ZIP_CODE, COUNTY_FIPS, County, Chapter, Region, Division, State, RCODE, DCODE, ECODE
            const zipIdx = headers.indexOf('ZIP_CODE');
            const fipsIdx = headers.indexOf('COUNTY_FIPS');
            const countyIdx = headers.indexOf('County');
            const ecodeIdx = headers.indexOf('ECODE');
            const rcodeIdx = headers.indexOf('RCODE');
            const dcodeIdx = headers.indexOf('DCODE');

            console.log('Loading comprehensive ZIP database (33K ZIPs, 99%+ US coverage)...');

            // Parse CSV rows into lookup object
            const lookupData = {};
            lines.slice(1).forEach(line => {
                const values = parseCSVLine(line);
                const zip = values[zipIdx];
                if (!zip) return;

                const countyName = values[countyIdx];
                const fips = values[fipsIdx];

                lookupData[zip] = {
                    county: countyName,
                    fips: fips || null,
                    ecode: values[ecodeIdx],
                    rcode: values[rcodeIdx],
                    dcode: values[dcodeIdx]
                };
            });

            console.log(`‚úì Loaded ${Object.keys(lookupData).length} ZIP code hierarchy mappings`);
            return lookupData;
        }

        function performHierarchicalRollup(baseAggregated, lookupData) {
            const result = {};

            // lookupData is now a simple object: { "zipcode": { county, ecode, rcode, dcode }, ... }
            // Convert to hierarchyMap with standardized keys AND store the codes for ID columns
            const hierarchyMap = {};
            Object.keys(lookupData).forEach(zip => {
                const data = lookupData[zip];
                hierarchyMap[zip] = {
                    county: data.county,
                    chapter: data.ecode,
                    region: data.rcode,
                    division: data.dcode,
                    // Store codes for audit columns
                    county_name: data.county,
                    fips: data.fips,
                    ecode: data.ecode,
                    rcode: data.rcode,
                    dcode: data.dcode
                };
            });

            // Calculate aggregates at all hierarchical levels
            const countyTotals = {};
            const chapterTotals = {};
            const regionTotals = {};
            const divisionTotals = {};

            Object.keys(baseAggregated).forEach(baseKey => {
                const hierarchy = hierarchyMap[baseKey];
                if (!hierarchy) return;

                const aggregates = baseAggregated[baseKey].aggregates;

                // Accumulate to county level
                if (hierarchy.county) {
                    if (!countyTotals[hierarchy.county]) {
                        countyTotals[hierarchy.county] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            countyTotals[hierarchy.county][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        countyTotals[hierarchy.county][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to chapter level
                if (hierarchy.chapter) {
                    if (!chapterTotals[hierarchy.chapter]) {
                        chapterTotals[hierarchy.chapter] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            chapterTotals[hierarchy.chapter][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        chapterTotals[hierarchy.chapter][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to region level
                if (hierarchy.region) {
                    if (!regionTotals[hierarchy.region]) {
                        regionTotals[hierarchy.region] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            regionTotals[hierarchy.region][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        regionTotals[hierarchy.region][field.field] += aggregates[field.field] || 0;
                    });
                }

                // Accumulate to division level
                if (hierarchy.division) {
                    if (!divisionTotals[hierarchy.division]) {
                        divisionTotals[hierarchy.division] = {};
                        rollupAggregationConfig.fields.forEach(field => {
                            divisionTotals[hierarchy.division][field.field] = 0;
                        });
                    }
                    rollupAggregationConfig.fields.forEach(field => {
                        divisionTotals[hierarchy.division][field.field] += aggregates[field.field] || 0;
                    });
                }
            });

            // For each selected output level, create CSV with hierarchical columns
            rollupAggregationConfig.outputLevels.forEach(level => {
                const levelData = [];

                if (level === 'zip') {
                    // Each row is a ZIP with its own totals + parent totals
                    Object.keys(baseAggregated).forEach(zipKey => {
                        const hierarchy = hierarchyMap[zipKey];
                        if (!hierarchy) return;

                        const row = {
                            key: zipKey,
                            // Add ID columns for auditing
                            county_name: hierarchy.county_name,
                            fips: hierarchy.fips,
                            ecode: hierarchy.ecode,
                            rcode: hierarchy.rcode,
                            dcode: hierarchy.dcode,
                            // Add aggregated data
                            zip: baseAggregated[zipKey].aggregates,
                            county: countyTotals[hierarchy.county] || {},
                            chapter: chapterTotals[hierarchy.chapter] || {},
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'county') {
                    // Each row is a County with its own totals + parent totals
                    Object.keys(countyTotals).forEach(countyKey => {
                        // Find a ZIP in this county to get hierarchy
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.county === countyKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: countyKey,
                            county: countyTotals[countyKey],
                            chapter: chapterTotals[hierarchy.chapter] || {},
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'chapter') {
                    // Each row is a Chapter with its own totals + parent totals
                    Object.keys(chapterTotals).forEach(chapterKey => {
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.chapter === chapterKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: chapterKey,
                            chapter: chapterTotals[chapterKey],
                            region: regionTotals[hierarchy.region] || {},
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'region') {
                    // Each row is a Region with its own totals + parent totals
                    Object.keys(regionTotals).forEach(regionKey => {
                        const sampleZip = Object.keys(baseAggregated).find(zip => hierarchyMap[zip]?.region === regionKey);
                        if (!sampleZip) return;
                        const hierarchy = hierarchyMap[sampleZip];

                        const row = {
                            key: regionKey,
                            region: regionTotals[regionKey],
                            division: divisionTotals[hierarchy.division] || {}
                        };
                        levelData.push(row);
                    });
                } else if (level === 'division') {
                    // Each row is a Division with its own totals only
                    Object.keys(divisionTotals).forEach(divisionKey => {
                        const row = {
                            key: divisionKey,
                            division: divisionTotals[divisionKey]
                        };
                        levelData.push(row);
                    });
                }

                // Convert to CSV format
                const csv = convertToCSV(level, levelData);
                result[level] = csv;
            });

            return result;
        }

        function convertToCSV(level, data) {
            const levelKeyName = level === 'zip' ? 'ZIP' :
                                level === 'county' ? 'County' :
                                level === 'chapter' ? 'ECODE' :
                                level === 'region' ? 'RCODE' : 'DCODE';

            // Create hierarchical headers based on output level
            const headers = [levelKeyName];

            // Add ID columns for auditing (for ZIP level output)
            if (level === 'zip') {
                headers.push('County', 'FIPS', 'ECODE', 'RCODE', 'DCODE');
            }

            const levelOrder = {
                'zip': ['zip', 'county', 'chapter', 'region', 'division'],
                'county': ['county', 'chapter', 'region', 'division'],
                'chapter': ['chapter', 'region', 'division'],
                'region': ['region', 'division'],
                'division': ['division']
            };

            const levelsToInclude = levelOrder[level] || [level];
            const levelLabels = {
                'zip': 'ZIP',
                'county': 'County',
                'chapter': 'Chapter',
                'region': 'Region',
                'division': 'Division'
            };

            // Add headers for each hierarchical level
            levelsToInclude.forEach(lvl => {
                rollupAggregationConfig.fields.forEach(field => {
                    headers.push(`${field.label} (${levelLabels[lvl]})`);
                });
            });

            const rows = [headers.join(',')];

            // Add data rows
            data.forEach(rowData => {
                const values = [rowData.key];

                // Add ID values for auditing (for ZIP level output)
                if (level === 'zip') {
                    values.push(
                        `"${rowData.county_name || ''}"`,
                        rowData.fips || '',
                        rowData.ecode || '',
                        rowData.rcode || '',
                        rowData.dcode || ''
                    );
                }

                levelsToInclude.forEach(lvl => {
                    rollupAggregationConfig.fields.forEach(field => {
                        const value = rowData[lvl] && rowData[lvl][field.field] !== undefined
                            ? rowData[lvl][field.field]
                            : 0;
                        values.push(value);
                    });
                });

                rows.push(values.join(','));
            });

            return rows.join('\n');
        }

        function displayRollupDownloadLinks() {
            rollupResultSection.style.display = 'block';
            rollupResultGrid.innerHTML = '';

            rollupAggregationConfig.outputLevels.forEach(level => {
                if (rollupGeneratedCSVs[level]) {
                    const csv = rollupGeneratedCSVs[level];
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const size = blob.size;

                    const card = createRollupResultCard(level, `${level}_aggregated.csv`, size, csv);
                    rollupResultGrid.appendChild(card);
                }
            });
        }

        function createRollupResultCard(level, filename, sizeBytes, csvContent) {
            const levelInfo = {
                zip: { icon: 'üì¶', name: 'ZIP Codes' },
                county: { icon: 'üèõÔ∏è', name: 'Counties' },
                chapter: { icon: 'üìö', name: 'Chapters' },
                region: { icon: 'üó∫Ô∏è', name: 'Regions' },
                division: { icon: 'üåé', name: 'Divisions' }
            };

            const info = levelInfo[level] || { icon: 'üìÑ', name: level };

            const card = document.createElement('div');
            card.style.cssText = 'background: white; border: 2px solid #e0e0e0; border-radius: 3px; padding: 15px; transition: all 0.2s;';

            card.innerHTML = `
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                    <div style="font-size: 2em;">${info.icon}</div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; font-size: 1.05em; margin-bottom: 2px;">${info.name}</div>
                        <div style="font-size: 0.85em; color: #666;">${(sizeBytes / 1024).toFixed(2)} KB</div>
                    </div>
                </div>
                <button class="download-btn" style="width: 100%; padding: 10px; background: #DC143C; color: white; border: none; border-radius: 3px; cursor: pointer; font-weight: 500; transition: all 0.2s;">
                    üíæ Download CSV
                </button>
            `;

            const downloadBtn = card.querySelector('.download-btn');
            downloadBtn.addEventListener('click', () => {
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            });

            downloadBtn.addEventListener('mouseenter', () => {
                downloadBtn.style.background = '#b01030';
            });

            downloadBtn.addEventListener('mouseleave', () => {
                downloadBtn.style.background = '#DC143C';
            });

            return card;
        }

        function updateRollupProgress(percent, message) {
            rollupProgressFill.style.width = percent + '%';
            rollupProgressFill.textContent = Math.round(percent) + '%';
            rollupStatus.textContent = message;
        }

        // ==================== END CSV ROLL-UP TAB ====================

        // Code Lookup functionality - Built-in database
        let lookupData = [];
        let countyData = [];
        let zipData = [];
        let zipDataByState = {}; // Cache for state-based ZIP files

        // Load built-in database
        function loadBuiltInDatabase() {
            // This will be populated from the embedded lookup_data.js file
            // For now, initialize empty - will be loaded via script tag
            if (typeof LOOKUP_DATABASE !== 'undefined') {
                lookupData = LOOKUP_DATABASE.chapters || [];
                countyData = LOOKUP_DATABASE.counties || [];
                
                console.log(`‚úì Loaded ${lookupData.length} chapters and ${countyData.length} counties`);
            }
            
            // Load ZIP code mapping (full database)
            if (typeof ZIP_TO_FIPS !== 'undefined') {
                zipData = ZIP_TO_FIPS.zipCodes || [];
                console.log(`‚úì Loaded ${zipData.length} ZIP codes`);
            }
        }

        // Load ZIP codes for a specific state (on-demand)
        async function loadZipCodesForState(state) {
            if (zipDataByState[state]) {
                return zipDataByState[state];
            }
            
            // Try to load state-specific file
            const stateUpper = state.toUpperCase();
            try {
                const script = document.createElement('script');
                script.src = `zip_codes_${stateUpper}.js`;
                script.onload = function() {
                    const stateVarName = `ZIP_CODES_${stateUpper}`;
                    if (typeof window[stateVarName] !== 'undefined') {
                        zipDataByState[state] = window[stateVarName];
                        console.log(`‚úì Loaded ${zipDataByState[state].length} ZIP codes for ${state}`);
                    }
                };
                document.head.appendChild(script);
            } catch (e) {
                console.log(`Could not load ZIP codes for ${state}`);
            }
            
            return zipDataByState[state] || [];
        }

        function searchCodes() {
            // Get all search values
            const chapterQuery = document.getElementById('chapterSearch').value.trim();
            const regionQuery = document.getElementById('regionSearch').value.trim();
            const divisionQuery = document.getElementById('divisionSearch').value.trim();
            const zipQuery = document.getElementById('zipSearch').value.trim();
            const countyQuery = document.getElementById('countySearch').value.trim();
            const stateQuery = document.getElementById('stateSearch').value.trim();
            const fipsQuery = document.getElementById('fipsSearch').value.trim();

            // Check if any search is active
            const hasSearch = chapterQuery || regionQuery || divisionQuery || zipQuery || countyQuery || stateQuery || fipsQuery;
            
            if (!hasSearch) {
                document.getElementById('noResults').style.display = 'block';
                document.getElementById('codeResults').style.display = 'none';
                document.getElementById('countyResultsSection').style.display = 'none';
                return;
            } else {
                document.getElementById('noResults').style.display = 'none';
            }

            // Normalize queries for flexible matching
            const normalize = (str) => str ? str.toLowerCase().trim().replace(/\s+/g, ' ') : '';
            
            // Convert state name to abbreviation if needed
            function normalizeState(stateQuery) {
                if (!stateQuery) return '';
                const normalized = normalize(stateQuery);
                // Check if it's already an abbreviation (2 letters)
                if (normalized.length === 2) {
                    return normalized.toUpperCase();
                }
                // Check if it's a full state name
                if (typeof STATE_NAMES !== 'undefined' && STATE_NAMES[normalized]) {
                    return STATE_NAMES[normalized];
                }
                // Return as-is for partial matching
                return normalized;
            }
            
            // Search Red Cross codes (forward and reverse lookup)
            let results = [];
            if (lookupData.length > 0) {
                results = lookupData.filter(item => {
                    // Chapter/ECODE search - very flexible
                    const chapterMatch = !chapterQuery || 
                        (item.Chapter && normalize(item.Chapter).includes(normalize(chapterQuery))) ||
                        (item.ECODE && item.ECODE.toString().toLowerCase().includes(normalize(chapterQuery))) ||
                        (item.ECODE && item.ECODE.toString().includes(chapterQuery.trim()));
                    
                    // Region/RCODE search - very flexible
                    const regionMatch = !regionQuery || 
                        (item.Region && normalize(item.Region).includes(normalize(regionQuery))) ||
                        (item.RCODE && item.RCODE.toString().toLowerCase().includes(normalize(regionQuery))) ||
                        (item.RCODE && item.RCODE.toString().includes(regionQuery.trim()));
                    
                    // Division/DCODE search - very flexible
                    const divisionMatch = !divisionQuery || 
                        (item.Division && normalize(item.Division).includes(normalize(divisionQuery))) ||
                        (item.DCODE && item.DCODE.toString().toLowerCase().includes(normalize(divisionQuery))) ||
                        (item.DCODE && item.DCODE.toString().includes(divisionQuery.trim()));
                    
                    return chapterMatch && regionMatch && divisionMatch;
                });
            }

            // Search ZIP codes first (if ZIP is searched, find county/FIPS)
            let zipResults = [];
            let zipFoundFIPS = null;
            if (zipQuery) {
                // Normalize ZIP to exactly 5 digits
                const zipNormalized = zipQuery.replace(/[^0-9]/g, '').substring(0, 5).padStart(5, '0');
                
                // Search in main ZIP database
                if (zipData.length > 0) {
                    // First try exact match
                    zipResults = zipData.filter(item => {
                        if (!item.Zip) return false;
                        const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                        return itemZip === zipNormalized;
                    });
                    
                    // If no exact match, try partial match (first 3 digits)
                    if (zipResults.length === 0 && zipNormalized.length >= 3) {
                        const zipPrefix = zipNormalized.substring(0, 3);
                        zipResults = zipData.filter(item => {
                            if (!item.Zip) return false;
                            const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                            return itemZip.startsWith(zipPrefix);
                        });
                    }
                }
                
                // If still no results, try to infer state from ZIP prefix and load state file
                if (zipResults.length === 0 && zipNormalized.length >= 3) {
                    // ZIP codes starting with 33xxx are typically Florida
                    // We could add more logic here to map ZIP prefixes to states
                    const zipPrefix = zipNormalized.substring(0, 2);
                    // Common ZIP prefixes: 33=FL, 10-12=NY/NJ/PA, etc.
                    // For now, if ZIP starts with 33, try loading FL data
                    if (zipPrefix === '33') {
                        loadZipCodesForState('FL').then(flZips => {
                            if (flZips && flZips.length > 0) {
                                const found = flZips.filter(item => {
                                    if (!item.Zip) return false;
                                    const itemZip = item.Zip.replace(/[^0-9]/g, '').padStart(5, '0');
                                    return itemZip === zipNormalized;
                                });
                                if (found.length > 0) {
                                    zipResults = found;
                                    zipFoundFIPS = found[0].FIPS;
                                    searchCodes(); // Re-run search with new data
                                }
                            }
                        });
                    }
                }
                
                if (zipResults.length > 0) {
                    // Use the FIPS from ZIP results to filter county results
                    zipFoundFIPS = zipResults[0].FIPS;
                }
            }

            // Search counties (forward and reverse lookup)
            let countyResults = [];
            if (countyData.length > 0) {
                // Normalize state query (convert full name to abbreviation if needed)
                const stateQueryNormalized = stateQuery ? normalizeState(stateQuery) : '';
                
                countyResults = countyData.filter(item => {
                    // If ZIP was searched and found a FIPS, prioritize that
                    if (zipFoundFIPS && zipQuery) {
                        return item.FIPS === zipFoundFIPS;
                    }
                    
                    const countyMatch = !countyQuery || 
                        (item.County && normalize(item.County).includes(normalize(countyQuery)));
                    
                    // State matching: convert full name to abbreviation, then match
                    let stateMatch = true;
                    if (stateQuery) {
                        const itemState = (item.State || '').toUpperCase();
                        // stateQueryNormalized is already converted to abbreviation if it was a full name
                        // Match the normalized query (which is now an abbreviation) against the item's state
                        stateMatch = itemState === stateQueryNormalized.toUpperCase() ||
                            // Also allow partial matching on the original query
                            normalize(item.State || '').includes(normalize(stateQuery));
                    }
                    
                    const fipsMatch = !fipsQuery || 
                        (item.FIPS && item.FIPS.toString().includes(fipsQuery.trim()));
                    
                    return countyMatch && stateMatch && fipsMatch;
                });
            }
            
            // If ZIP search found results, add them to county results
            if (zipResults.length > 0 && zipQuery) {
                zipResults.forEach(zipItem => {
                    // Check if this FIPS is already in countyResults
                    const exists = countyResults.some(c => c.FIPS === zipItem.FIPS);
                    if (!exists) {
                        countyResults.push({
                            FIPS: zipItem.FIPS,
                            County: zipItem.County,
                            State: zipItem.State
                        });
                    }
                });
            }

            // Get state code from FIPS (first 2 digits)
            let stateCodeInfo = null;
            if (stateQuery && countyResults.length > 0) {
                const firstCounty = countyResults[0];
                if (firstCounty.FIPS && firstCounty.FIPS.length >= 2) {
                    stateCodeInfo = {
                        state: firstCounty.State,
                        stateCode: firstCounty.FIPS.substring(0, 2)
                    };
                }
            }

            // Show Red Cross code results
            if (results.length > 0 && (chapterQuery || regionQuery || divisionQuery)) {
                const uniqueResults = [];
                const seen = new Set();
                results.forEach(item => {
                    const key = `${item.Chapter}|${item.Region}|${item.Division}`;
                    if (!seen.has(key)) {
                        seen.add(key);
                        uniqueResults.push(item);
                    }
                });

                const resultsHtml = uniqueResults.slice(0, 50).map(item => `
                    <div style="padding: 12px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 3px; border-left: 3px solid #DC143C; margin-bottom: 8px;">
                        <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: start;">
                            <div>
                                <div style="font-weight: 600; color: #333; font-size: 0.95em; margin-bottom: 4px;">
                                    ${item.Chapter || 'N/A'}
                                </div>
                                ${item.Region ? `<div style="font-size: 0.85em; color: #666;">${item.Region}</div>` : ''}
                                ${item.Division ? `<div style="font-size: 0.85em; color: #666;">${item.Division}</div>` : ''}
                            </div>
                            <div style="font-size: 0.85em; color: #666;">
                                ${item.Region ? `<div>Region: ${item.Region}</div>` : ''}
                                ${item.Division ? `<div>Division: ${item.Division}</div>` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="margin-bottom: 6px;">
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">ECODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.ECODE || 'N/A'}</div>
                                </div>
                                <div style="margin-bottom: 6px;">
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">RCODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.RCODE || 'N/A'}</div>
                                </div>
                                <div>
                                    <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">DCODE</div>
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.1em;">${item.DCODE || 'N/A'}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

                document.getElementById('codeResultsContent').innerHTML = resultsHtml;
                document.getElementById('codeResults').style.display = 'block';
            } else {
                document.getElementById('codeResults').style.display = 'none';
            }

            // Show ZIP code results if ZIP was searched
            if (zipQuery) {
                if (zipResults.length > 0) {
                    const zipResultsHtml = zipResults.slice(0, 10).map(item => `
                        <div style="padding: 12px; background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; margin-bottom: 8px;">
                            <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; color: #333; font-size: 0.95em;">
                                        ZIP Code: ${item.Zip}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666; margin-top: 2px;">
                                        ${item.County || 'N/A'} County, ${item.State || 'N/A'}
                                    </div>
                                </div>
                                <div style="font-size: 0.85em; color: #666;">
                                    County FIPS Code
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.3em;">${item.FIPS || 'N/A'}</div>
                                    <div style="font-size: 0.7em; color: #999; margin-top: 2px;">
                                        State: ${item.FIPS ? item.FIPS.substring(0, 2) : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('');
                    
                    document.getElementById('countyResultsContent').innerHTML = zipResultsHtml;
                    document.getElementById('countyResultsSection').style.display = 'block';
                } else {
                    // ZIP not found - show message and don't show other county results
                    document.getElementById('countyResultsContent').innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #999;">
                            <div style="font-size: 1.1em; margin-bottom: 8px;">ZIP Code ${zipQuery} not found</div>
                            <div style="font-size: 0.9em;">This ZIP code is not in our database. Try searching by County Name or FIPS Code instead.</div>
                        </div>
                    `;
                    document.getElementById('countyResultsSection').style.display = 'block';
                    return; // Don't show other county results when ZIP search fails
                }
            }

            // Show county results with state code (only if ZIP was not searched, or ZIP search succeeded)
            if ((countyQuery || stateQuery || fipsQuery) && !zipQuery) {
                let countyResultsHtml = '';
                
                // Show state code if state was searched
                if (stateCodeInfo) {
                    countyResultsHtml += `
                        <div style="padding: 12px; background: #fff5f5; border: 2px solid #DC143C; border-radius: 3px; margin-bottom: 12px;">
                            <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                <div>
                                    <div style="font-weight: 600; color: #333; font-size: 1em;">
                                        ${stateCodeInfo.state}
                                    </div>
                                </div>
                                <div style="font-size: 0.9em; color: #666;">
                                    State Code (FIPS)
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #DC143C; font-weight: 700; font-size: 1.4em;">${stateCodeInfo.stateCode}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Show counties
                if (countyResults.length > 0) {
                    countyResultsHtml += countyResults.slice(0, 50).map(item => {
                        const stateCode = item.FIPS && item.FIPS.length >= 2 ? item.FIPS.substring(0, 2) : '';
                        return `
                            <div style="padding: 10px; background: #fafafa; border: 1px solid #e0e0e0; border-radius: 3px; border-left: 3px solid #DC143C; margin-bottom: 6px;">
                                <div style="display: grid; grid-template-columns: 2fr 1.5fr 1fr; gap: 15px; align-items: center;">
                                    <div>
                                        <div style="font-weight: 600; color: #333; font-size: 0.9em;">
                                            ${item.County || 'N/A'} County
                                        </div>
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        ${item.State || ''}${stateCode ? ` (State Code: ${stateCode})` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        <div style="font-size: 0.75em; color: #999; margin-bottom: 1px;">FIPS</div>
                                        <div style="color: #DC143C; font-weight: 700; font-size: 1.2em;">${item.FIPS || 'N/A'}</div>
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else if (stateQuery || fipsQuery || countyQuery) {
                    countyResultsHtml += `<div style="padding: 20px; text-align: center; color: #999;">No counties found</div>`;
                }

                if (countyResultsHtml) {
                    document.getElementById('countyResultsContent').innerHTML = countyResultsHtml;
                    document.getElementById('countyResultsSection').style.display = 'block';
                } else {
                    document.getElementById('countyResultsSection').style.display = 'none';
                }
            } else if (!zipQuery) {
                document.getElementById('countyResultsSection').style.display = 'none';
            }
        }

        // Reset all search fields
        function resetSearch() {
            document.getElementById('chapterSearch').value = '';
            document.getElementById('regionSearch').value = '';
            document.getElementById('divisionSearch').value = '';
            document.getElementById('zipSearch').value = '';
            document.getElementById('countySearch').value = '';
            document.getElementById('stateSearch').value = '';
            document.getElementById('fipsSearch').value = '';
            
            // Clear results
            document.getElementById('noResults').style.display = 'block';
            document.getElementById('codeResults').style.display = 'none';
            document.getElementById('countyResultsSection').style.display = 'none';
            document.getElementById('codeResultsContent').innerHTML = '';
            document.getElementById('countyResultsContent').innerHTML = '';
        }

        // Initialize
        updateOptionCards();

        // Load built-in database when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', loadBuiltInDatabase);
        } else {
            // DOM already loaded
            setTimeout(loadBuiltInDatabase, 100);
        }

        // ===== ORGLER URL CREATOR FUNCTIONS =====
        function convertToOrglerTool() {
            const powerbiUrl = document.getElementById('orglerPowerbiUrl').value.trim();

            if (!powerbiUrl) {
                alert('Please enter a Power BI URL');
                return;
            }

            if (!powerbiUrl.includes('powerbi.com') && !powerbiUrl.includes('app.powerbi.com')) {
                alert('Please enter a valid Power BI URL');
                return;
            }

            try {
                const url = new URL(powerbiUrl);
                const pathParts = url.pathname.split('/').filter(p => p);

                let reportId = null;
                const reportsIndex = pathParts.indexOf('reports');
                if (reportsIndex !== -1 && reportsIndex + 1 < pathParts.length) {
                    reportId = pathParts[reportsIndex + 1];
                } else {
                    const guidPattern = /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i;
                    const match = powerbiUrl.match(guidPattern);
                    if (match) reportId = match[0];
                }

                if (!reportId) {
                    throw new Error('Could not extract report ID from URL');
                }

                let orglerUrl = `https://orglerws.redcross.org/PowerBI/Home/report/${reportId}`;

                document.getElementById('orglerOutputText').value = orglerUrl;
                document.getElementById('orglerResultDiv').style.display = 'block';
            } catch (error) {
                alert('Error converting URL: ' + error.message);
            }
        }

        function copyOrglerUrlTool() {
            const output = document.getElementById('orglerOutputText');
            if (!output.value) {
                alert('No URL to copy');
                return;
            }

            output.select();
            navigator.clipboard.writeText(output.value).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(() => {
                alert('Failed to copy. Please select and copy manually.');
            });
        }

        // ===== POPUP CREATOR FUNCTIONS =====
        let popupToolFieldsData = [];

        function parsePopupFieldDefinitions() {
            const inputText = document.getElementById('popupToolFieldsInput').value.trim();
            if (!inputText) {
                alert('Please paste the field definitions from the ArcGIS REST page');
                return;
            }

            try {
                document.getElementById('popupToolFieldsContainer').style.display = 'none';
                document.getElementById('popupToolResult').style.display = 'none';

                const lines = inputText.split('\n').filter(line => line.trim());
                const fields = [];

                for (const line of lines) {
                    const nameMatch = line.match(/^([A-Za-z0-9_]+)\s*\(/);
                    if (!nameMatch) continue;

                    const name = nameMatch[1];
                    const aliasMatch = line.match(/alias:\s*([^,]+)/);
                    const alias = aliasMatch ? aliasMatch[1].trim() : name;
                    const typeMatch = line.match(/type:\s*(esri[A-Za-z]+)/);
                    const type = typeMatch ? typeMatch[1] : 'esriFieldTypeString';

                    fields.push({ name, alias, type });
                }

                if (fields.length === 0) {
                    throw new Error('No fields could be parsed');
                }

                popupToolFieldsData = fields.filter(field => {
                    const name = field.name.toUpperCase();
                    return name !== 'OBJECTID' && name !== 'SHAPE' && name !== 'GLOBALID' &&
                           !name.startsWith('SHAPE_') && field.type !== 'esriFieldTypeOID' &&
                           field.type !== 'esriFieldTypeGeometry';
                });

                if (popupToolFieldsData.length === 0) {
                    throw new Error('No usable fields found');
                }

                displayPopupToolFields();
                document.getElementById('popupToolFieldsContainer').style.display = 'block';

            } catch (error) {
                alert('Error parsing fields: ' + error.message);
            }
        }

        function displayPopupToolFields(filterText = '') {
            const container = document.getElementById('popupToolFieldList');
            container.innerHTML = '';

            const filtered = filterText ?
                popupToolFieldsData.filter(f =>
                    f.name.toLowerCase().includes(filterText.toLowerCase()) ||
                    (f.alias && f.alias.toLowerCase().includes(filterText.toLowerCase()))
                ) : popupToolFieldsData;

            filtered.forEach(field => {
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; padding: 8px; border-bottom: 1px solid #f0f0f0;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `popupToolField_${field.name}`;
                checkbox.checked = true;
                checkbox.style.marginRight = '10px';
                checkbox.addEventListener('change', updatePopupToolFieldCount);

                const label = document.createElement('label');
                label.htmlFor = `popupToolField_${field.name}`;
                label.style.cssText = 'flex: 1; cursor: pointer; font-size: 0.9em;';
                label.innerHTML = `<strong>${escapeHtmlTool(field.alias || field.name)}</strong> <span style="color: #999; font-size: 0.85em;">(${field.name})</span>`;

                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });

            updatePopupToolFieldCount();
        }

        function filterPopupToolFields() {
            const filterText = document.getElementById('popupToolFieldFilter').value;
            displayPopupToolFields(filterText);
        }

        function updatePopupToolFieldCount() {
            const checked = document.querySelectorAll('#popupToolFieldList input[type="checkbox"]:checked').length;
            document.getElementById('popupToolFieldCount').textContent = checked;
        }

        function generatePopupToolHTML() {
            const checkedBoxes = document.querySelectorAll('#popupToolFieldList input[type="checkbox"]:checked');
            if (checkedBoxes.length === 0) {
                alert('Please select at least one field');
                return;
            }

            const selectedFields = Array.from(checkedBoxes).map(cb => {
                const fieldName = cb.id.replace('popupToolField_', '');
                return popupToolFieldsData.find(f => f.name === fieldName);
            }).filter(f => f);

            const title = document.getElementById('popupToolTitle').value.trim() || 'Feature Information';
            const groupsText = document.getElementById('popupToolGroups').value.trim();

            const groups = groupsText ?
                groupsText.split('\n').map(line => line.split(',').map(f => f.trim()).filter(f => f)).filter(g => g.length > 0) : [];

            let html = `<div style="background-color:#fff;border-radius:10px;border:1px solid #e0e0e0;box-shadow:0 1px 3px rgba(0,0,0,0.1);padding:10px;font-family:'Arial',sans-serif;color:#333;font-size:13px;line-height:1.4;">\n`;
            html += `  <h3 style="color:#c8102e;margin-top:0;margin-bottom:12px;font-size:16px;font-weight:600;">${escapeHtmlTool(title)}</h3>\n`;

            if (groups.length > 0) {
                const usedFields = new Set();
                groups.forEach((group, groupIndex) => {
                    group.forEach(fieldName => {
                        const field = selectedFields.find(f =>
                            f.name.toLowerCase() === fieldName.toLowerCase() ||
                            (f.alias && f.alias.toLowerCase() === fieldName.toLowerCase())
                        );
                        if (field) {
                            usedFields.add(field.name);
                            html += `  <p style="margin:6px 0;"><b>${escapeHtmlTool(field.alias || field.name)}:</b> {${field.name}}</p>\n`;
                        }
                    });
                    if (groupIndex < groups.length - 1) {
                        html += `  <hr style="border:none;border-top:1px solid #ddd;margin:8px 0;">\n`;
                    }
                });

                const remainingFields = selectedFields.filter(f => !usedFields.has(f.name));
                if (remainingFields.length > 0) {
                    if (groups.length > 0) {
                        html += `  <hr style="border:none;border-top:1px solid #ddd;margin:8px 0;">\n`;
                    }
                    remainingFields.forEach(field => {
                        html += `  <p style="margin:6px 0;"><b>${escapeHtmlTool(field.alias || field.name)}:</b> {${field.name}}</p>\n`;
                    });
                }
            } else {
                selectedFields.forEach(field => {
                    html += `  <p style="margin:6px 0;"><b>${escapeHtmlTool(field.alias || field.name)}:</b> {${field.name}}</p>\n`;
                });
            }

            html += `</div>`;

            document.getElementById('popupToolOutput').value = html;
            document.getElementById('popupToolPreview').innerHTML = html.replace(/\{([^}]+)\}/g, '<span style="color:#666;font-style:italic;">{$1}</span>');
            document.getElementById('popupToolResult').style.display = 'block';
        }

        function escapeHtmlTool(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyPopupToolHTML() {
            const output = document.getElementById('popupToolOutput');
            if (!output.value) {
                alert('No HTML to copy');
                return;
            }

            output.select();
            navigator.clipboard.writeText(output.value).then(() => {
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = originalText, 2000);
            }).catch(() => alert('Failed to copy'));
        }

        function downloadPopupToolHTML() {
            const html = document.getElementById('popupToolOutput').value;
            if (!html) {
                alert('No HTML to download');
                return;
            }

            const blob = new Blob([html], { type: 'text/html' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'arcgis_popup.html';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function downloadPopupToolTXT() {
            const html = document.getElementById('popupToolOutput').value;
            if (!html) {
                alert('No HTML to download');
                return;
            }

            const blob = new Blob([html], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'arcgis_popup.txt';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        // ===== MAPBOX GEOCODER FUNCTIONS =====
        let geocoderFile = null;
        let geocoderCsvData = null;
        let geocoderGeocodedData = null;
        let geocoderHasExistingCoordinates = false;

        // Add drag-and-drop support for geocoder file upload
        (function() {
            const dropZone = document.getElementById('geocoderDropZone');
            const fileInput = document.getElementById('geocoderFileInput');

            if (!dropZone || !fileInput) return;

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = '#DC143C';
                dropZone.style.background = '#fff5f5';
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.style.borderColor = '#e0e0e0';
                dropZone.style.background = '#fafafa';
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.style.borderColor = '#e0e0e0';
                dropZone.style.background = '#fafafa';

                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith('.csv')) {
                    fileInput.files = e.dataTransfer.files;
                    handleGeocoderFileSelect({ target: fileInput });
                } else {
                    alert('Please drop a CSV file');
                }
            });
        })();

        function checkForExistingGeocoderCoordinates(sampleRow) {
            const coordinateColumns = ['Latitude', 'Longitude', 'latitude', 'longitude', 'Lat', 'Lon', 'lat', 'lon', 'Y', 'X', 'y', 'x'];
            geocoderHasExistingCoordinates = coordinateColumns.some(col => sampleRow.hasOwnProperty(col));

            if (geocoderHasExistingCoordinates) {
                document.getElementById('geocoderCoordinateWarning').style.display = 'block';
            }
        }

        function handleGeocoderFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.csv')) {
                alert('Please upload a CSV file');
                return;
            }

            geocoderFile = file;

            const fileNameDiv = document.getElementById('geocoderFileName');
            fileNameDiv.innerHTML = `
                <div style="background: #e8f5e9; border: 2px solid #4CAF50; border-radius: 3px; padding: 10px; display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 1.2em;">File uploaded: ${file.name}</span>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #2e7d32;">Size: ${(file.size / 1024).toFixed(2)} KB</div>
                    </div>
                    <button onclick="clearGeocoderFile()" style="background: #f44336; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 0.85em;">Remove</button>
                </div>
            `;

            const reader = new FileReader();
            reader.onload = (e) => {
                const csvText = e.target.result;
                geocoderCsvData = parseCSVForGeocoder(csvText);

                if (geocoderCsvData && geocoderCsvData.length > 0) {
                    showGeocoderColumnSelector(geocoderCsvData[0]);
                    checkForExistingGeocoderCoordinates(geocoderCsvData[0]);
                }
            };
            reader.readAsText(file);
        }

        function clearGeocoderFile() {
            geocoderFile = null;
            geocoderCsvData = null;
            document.getElementById('geocoderFileInput').value = '';
            document.getElementById('geocoderFileName').innerHTML = '';
            document.getElementById('geocoderColumnSelector').style.display = 'none';
            document.getElementById('geocoderGeocodingOptions').style.display = 'none';
            document.getElementById('geocoderGeocodeBtn').style.display = 'none';
            document.getElementById('geocoderProgress').style.display = 'none';
            document.getElementById('geocoderResults').style.display = 'none';
        }

        function parseCSVForGeocoder(text) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length < 2) return null;

            function parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const nextChar = line[i + 1];

                    if (char === '"') {
                        if (inQuotes && nextChar === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            const headers = parseCSVLine(lines[0]).map(h => h.replace(/^"|"$/g, ''));
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]).map(v => v.replace(/^"|"$/g, ''));
                if (values.length >= headers.length) {
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = (values[index] || '').trim();
                    });
                    data.push(row);
                }
            }

            return data;
        }

        function showGeocoderColumnSelector(headers) {
            const container = document.getElementById('geocoderColumnOptions');
            container.innerHTML = '';

            const components = [
                { id: 'geocoderStreet', label: 'Street Address', suggestions: ['street', 'address', 'addr', 'location'] },
                { id: 'geocoderCity', label: 'City', suggestions: ['city', 'town', 'municipality'] },
                { id: 'geocoderState', label: 'State', suggestions: ['state', 'st', 'province'] },
                { id: 'geocoderZip', label: 'ZIP Code', suggestions: ['zip', 'postal', 'postcode', 'zipcode'] }
            ];

            components.forEach(comp => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label style="display: block; font-weight: 600; margin-bottom: 5px; color: #333; font-size: 0.9em;">${comp.label}:</label>
                    <select id="${comp.id}" style="width: 100%; padding: 8px; border: 2px solid #e0e0e0; border-radius: 3px; font-size: 0.9em; background: white;">
                        <option value="">-- Select Column --</option>
                        ${Object.keys(headers).map(h => {
                            const lower = h.toLowerCase();
                            const isMatch = comp.suggestions.some(s => lower.includes(s));
                            return `<option value="${h}" ${isMatch ? 'selected' : ''}>${h}</option>`;
                        }).join('')}
                    </select>
                `;
                container.appendChild(div);
            });

            document.getElementById('geocoderColumnSelector').style.display = 'block';
            document.getElementById('geocoderGeocodingOptions').style.display = 'block';
            document.getElementById('geocoderGeocodeBtn').style.display = 'block';
        }

        async function startGeocoderGeocoding() {
            const token = document.getElementById('geocoderMapboxToken').value.trim();
            if (!token) {
                alert('Please enter your Mapbox access token');
                return;
            }

            if (!geocoderFile || !geocoderCsvData || geocoderCsvData.length === 0) {
                alert('Please upload a CSV file first');
                return;
            }

            const streetCol = document.getElementById('geocoderStreet').value;
            const cityCol = document.getElementById('geocoderCity').value;
            const stateCol = document.getElementById('geocoderState').value;
            const zipCol = document.getElementById('geocoderZip').value;

            if (!streetCol && !cityCol) {
                alert('Please select at least a Street Address or City column');
                return;
            }

            document.getElementById('geocoderProgress').style.display = 'block';
            document.getElementById('geocoderGeocodeBtn').disabled = true;
            document.getElementById('geocoderResults').style.display = 'none';

            const countryCode = document.getElementById('geocoderCountryCode').value.trim() || 'US';
            const includeOriginal = document.getElementById('geocoderIncludeOriginal').checked;

            geocoderGeocodedData = [];
            const total = geocoderCsvData.length;
            let successCount = 0;
            let failCount = 0;

            for (let i = 0; i < total; i++) {
                const row = geocoderCsvData[i];

                const addressParts = [];
                if (streetCol && row[streetCol] && row[streetCol].trim()) {
                    addressParts.push(row[streetCol].trim());
                }
                if (cityCol && row[cityCol] && row[cityCol].trim()) {
                    addressParts.push(row[cityCol].trim());
                }
                if (stateCol && row[stateCol] && row[stateCol].trim()) {
                    addressParts.push(row[stateCol].trim());
                }
                if (zipCol && row[zipCol] && row[zipCol].trim()) {
                    addressParts.push(row[zipCol].trim());
                }

                const address = addressParts.join(', ');

                if (!address || address.trim() === '') {
                    const cleanedRow = includeOriginal ? { ...row } : {};
                    delete cleanedRow.Latitude;
                    delete cleanedRow.Longitude;
                    delete cleanedRow.latitude;
                    delete cleanedRow.longitude;
                    delete cleanedRow.Lat;
                    delete cleanedRow.Lon;
                    delete cleanedRow.Y;
                    delete cleanedRow.X;

                    const failedRow = {
                        ...cleanedRow,
                        address: 'No address data',
                        Latitude: '',
                        Longitude: '',
                        geocoded_address: 'Skipped - no address data',
                        confidence: 'N/A'
                    };
                    geocoderGeocodedData.push(failedRow);
                    failCount++;

                    const progress = ((i + 1) / total) * 100;
                    document.getElementById('geocoderProgressBar').style.width = progress + '%';
                    document.getElementById('geocoderProgressBar').textContent = Math.round(progress) + '%';
                    document.getElementById('geocoderProgressText').textContent = `Skipping ${i + 1} of ${total}: No address data`;
                    continue;
                }

                const progress = ((i + 1) / total) * 100;
                document.getElementById('geocoderProgressBar').style.width = progress + '%';
                document.getElementById('geocoderProgressBar').textContent = Math.round(progress) + '%';
                document.getElementById('geocoderProgressText').textContent = `Geocoding ${i + 1} of ${total}: ${address.substring(0, 50)}...`;

                try {
                    const encodedAddress = encodeURIComponent(address);
                    const url = `https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedAddress}.json?access_token=${token}&country=${countryCode}&limit=1`;

                    const response = await fetch(url);

                    if (!response.ok) {
                        if (response.status === 401) {
                            throw new Error('Unauthorized - Check your Mapbox access token');
                        }
                        const errorText = await response.text();
                        throw new Error(`Mapbox API error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(`Mapbox API error: ${data.error}`);
                    }

                    if (data.features && data.features.length > 0) {
                        const feature = data.features[0];
                        const [lng, lat] = feature.center;

                        const replaceCoordinates = document.querySelector('input[name="geocoderCoordinateHandling"]:checked')?.value === 'replace';
                        const cleanedRow = includeOriginal ? { ...row } : {};

                        if (replaceCoordinates || !includeOriginal) {
                            delete cleanedRow.Latitude;
                            delete cleanedRow.Longitude;
                            delete cleanedRow.latitude;
                            delete cleanedRow.longitude;
                            delete cleanedRow.Lat;
                            delete cleanedRow.Lon;
                            delete cleanedRow.Y;
                            delete cleanedRow.X;
                        }

                        const geocodedRow = {
                            ...cleanedRow,
                            address: address,
                            Latitude: lat,
                            Longitude: lng,
                            geocoded_address: feature.place_name,
                            confidence: feature.properties.confidence || 'N/A'
                        };

                        geocoderGeocodedData.push(geocodedRow);
                        successCount++;
                    } else {
                        const cleanedRow = includeOriginal ? { ...row } : {};
                        delete cleanedRow.Latitude;
                        delete cleanedRow.Longitude;
                        delete cleanedRow.latitude;
                        delete cleanedRow.longitude;
                        delete cleanedRow.Lat;
                        delete cleanedRow.Lon;
                        delete cleanedRow.Y;
                        delete cleanedRow.X;

                        const failedRow = {
                            ...cleanedRow,
                            address: address,
                            Latitude: '',
                            Longitude: '',
                            geocoded_address: 'Not found',
                            confidence: 'N/A'
                        };
                        geocoderGeocodedData.push(failedRow);
                        failCount++;
                    }
                } catch (error) {
                    const cleanedRow = includeOriginal ? { ...row } : {};
                    delete cleanedRow.Latitude;
                    delete cleanedRow.Longitude;
                    delete cleanedRow.latitude;
                    delete cleanedRow.longitude;
                    delete cleanedRow.Lat;
                    delete cleanedRow.Lon;
                    delete cleanedRow.Y;
                    delete cleanedRow.X;

                    const failedRow = {
                        ...cleanedRow,
                        address: address,
                        Latitude: '',
                        Longitude: '',
                        geocoded_address: 'Error: ' + error.message,
                        confidence: 'N/A'
                    };
                    geocoderGeocodedData.push(failedRow);
                    failCount++;
                }

                await new Promise(resolve => setTimeout(resolve, 100));
            }

            document.getElementById('geocoderProgressBar').style.width = '100%';
            document.getElementById('geocoderProgressBar').textContent = '100%';
            document.getElementById('geocoderProgressText').textContent = `Complete! ${successCount} geocoded, ${failCount} failed.`;

            document.getElementById('geocoderResultsSummary').innerHTML = `
                <strong>Geocoding Results:</strong><br>
                Successfully geocoded: ${successCount} addresses<br>
                Failed: ${failCount} addresses<br>
                Total processed: ${total} addresses
            `;

            document.getElementById('geocoderResults').style.display = 'block';
            document.getElementById('geocoderGeocodeBtn').disabled = false;
        }

        function downloadGeocoderGeoJSON() {
            if (!geocoderGeocodedData || geocoderGeocodedData.length === 0) {
                alert('No geocoded data to download');
                return;
            }

            const features = geocoderGeocodedData
                .filter(row => {
                    const lat = row.Latitude || row.latitude;
                    const lng = row.Longitude || row.longitude;
                    return lat && lng && lat !== '' && lng !== '';
                })
                .map(row => {
                    const lat = parseFloat(row.Latitude || row.latitude);
                    const lng = parseFloat(row.Longitude || row.longitude);
                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [lng, lat]
                        },
                        properties: Object.fromEntries(
                            Object.entries(row).filter(([key]) =>
                                key !== 'latitude' && key !== 'longitude' &&
                                key !== 'Latitude' && key !== 'Longitude'
                            )
                        )
                    };
                });

            const geojson = {
                type: 'FeatureCollection',
                features: features
            };

            const blob = new Blob([JSON.stringify(geojson, null, 2)], { type: 'application/json' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = geocoderFile.name.replace('.csv', '_geocoded.geojson');
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function downloadGeocoderCSV() {
            if (!geocoderGeocodedData || geocoderGeocodedData.length === 0) {
                alert('No geocoded data to download');
                return;
            }

            const cleanedData = geocoderGeocodedData.map(row => {
                const cleaned = { ...row };

                const lat = cleaned.Latitude || cleaned.latitude || '';
                const lng = cleaned.Longitude || cleaned.longitude || '';

                delete cleaned.latitude;
                delete cleaned.longitude;
                delete cleaned.Latitude;
                delete cleaned.Longitude;
                delete cleaned.Lat;
                delete cleaned.Lon;
                delete cleaned.Y;
                delete cleaned.X;

                cleaned.Latitude = lat && lat !== '' && lat !== '0' ? parseFloat(lat).toFixed(6) : '';
                cleaned.Longitude = lng && lng !== '' && lng !== '0' ? parseFloat(lng).toFixed(6) : '';

                return cleaned;
            });

            const allHeaders = Object.keys(cleanedData[0]);
            const coordinateHeaders = ['Latitude', 'Longitude'];
            const otherHeaders = allHeaders.filter(h => !coordinateHeaders.includes(h));

            const finalHeaders = [...coordinateHeaders, ...otherHeaders];

            const csvRows = [
                finalHeaders.join(','),
                ...cleanedData.map(row =>
                    finalHeaders.map(header => {
                        let value = row[header] || '';
                        if ((header === 'Latitude' || header === 'Longitude') && value !== '') {
                            const num = parseFloat(value);
                            if (!isNaN(num)) {
                                value = num.toFixed(6);
                            }
                        } else {
                            value = `"${String(value).replace(/"/g, '""')}"`;
                        }
                        return value;
                    }).join(',')
                )
            ];

            const csv = csvRows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = geocoderFile.name.replace('.csv', '_geocoded.csv');
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }
    </script>
</body>
</html>

